{"task_id": "OOP/0", "completion": "class WDS:\n    def without_duplicates(self, s: str) -> int:\n        char_index_map = {}\n        max_length = 0\n        start = 0\n        \n        for i, char in enumerate(s):\n            if char in char_index_map and char_index_map[char] >= start:\n                start = char_index_map[char] + 1\n            char_index_map[char] = i\n            max_length = max(max_length, i - start + 1)\n        \n        return max_length"}
{"task_id": "OOP/1", "completion": "class MNS:\n    def __init__(self, machines):\n        self.machines = machines\n\n    def __private_Ministeps(self):\n        total_clothes = sum(self.machines)\n        n = len(self.machines)\n        target = total_clothes // n\n        remainder = total_clothes % n\n        \n        steps = 0\n        balance = 0\n        \n        for clothes in self.machines:\n            balance += clothes - target\n            steps += abs(balance)\n        \n        return steps + (1 if remainder > 0 else 0)\n\n    def public_Ministeps(self):\n        return self.__private_Ministeps()"}
{"task_id": "OOP/2", "completion": "class FTM:\n    def find_the_median(self, nums1, nums2):\n        # Combine the two sorted arrays\n        combined = sorted(nums1 + nums2)\n        n = len(combined)\n        mid = n // 2\n        \n        if n % 2 == 0:\n            # If even, return the average of the two middle elements\n            return (combined[mid - 1] + combined[mid]) / 2\n        else:\n            # If odd, return the middle element\n            return combined[mid]"}
{"task_id": "OOP/3", "completion": "class PDSB:\n    def pa_substring(self, s: str) -> str:\n        def expand_around_center(left: int, right: int) -> str:\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        longest_palindrome = \"\"\n        for i in range(len(s)):\n            # Odd length palindromes\n            substring1 = expand_around_center(i, i)\n            # Even length palindromes\n            substring2 = expand_around_center(i, i + 1)\n\n            if len(substring1) > len(longest_palindrome):\n                longest_palindrome = substring1\n            if len(substring2) > len(longest_palindrome):\n                longest_palindrome = substring2\n\n        return longest_palindrome"}
{"task_id": "OOP/4", "completion": "class ZZPTN:\n    def Zigzag_pattern(self, s: str, numRows: int) -> str:\n        if numRows <= 1 or numRows >= len(s):\n            return s\n\n        rows = [''] * numRows\n        current_row, going_down = 0, False\n\n        for char in s:\n            rows[current_row] += char\n            if current_row == 0:\n                going_down = True\n            elif current_row == numRows - 1:\n                going_down = False\n            \n            current_row += 1 if going_down else -1\n\n        return ''.join(rows)"}
{"task_id": "OOP/5", "completion": "class ITOC:\n    def Invert_outcome(self, x: int) -> int:\n        sign = -1 if x < 0 else 1\n        x_abs = abs(x)\n        reversed_num = int(str(x_abs)[::-1])\n        if reversed_num > 2**31 - 1:\n            return 0\n        return sign * reversed_num"}
{"task_id": "OOP/6", "completion": "class PDIT:\n    def Palindromic_integer(self, x):\n        x_str = str(x)\n        return x_str == x_str[::-1]"}
{"task_id": "OOP/7", "completion": "class RLMH:\n    def rule_matching(self, s: str, p: str) -> bool:\n        def match(i: int, j: int) -> bool:\n            if j == len(p):\n                return i == len(s)\n            first_match = i < len(s) and (s[i] == p[j] or p[j] == '.')\n            if j + 1 < len(p) and p[j + 1] == '*':\n                return (match(i, j + 2) or\n                        first_match and match(i + 1, j))\n            return first_match and match(i + 1, j + 1)\n\n        return match(0, 0)"}
{"task_id": "OOP/8", "completion": "class LCMP:\n    def longest_common_prefix(self, strs):\n        if not strs:\n            return \"\"\n        \n        shortest_str = min(strs, key=len)\n        \n        for i in range(len(shortest_str)):\n            for string in strs:\n                if string[i] != shortest_str[i]:\n                    return shortest_str[:i]\n        \n        return shortest_str"}
{"task_id": "OOP/9", "completion": "class TSOTN:\n    def sum_three_numbers(self, nums, target):\n        nums.sort()\n        closest_sum = float('inf')\n        \n        for i in range(len(nums) - 2):\n            left, right = i + 1, len(nums) - 1\n            \n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                \n                if abs(target - current_sum) < abs(target - closest_sum):\n                    closest_sum = current_sum\n                \n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    return current_sum\n        \n        return closest_sum"}
{"task_id": "OOP/10", "completion": "class VLD_ST:\n    def valid_string(self, s: str) -> bool:\n        stack = []\n        bracket_map = {')': '(', '}': '{', ']': '['}\n        \n        for char in s:\n            if char in bracket_map.values():  # if it's one of the left brackets\n                stack.append(char)\n            elif char in bracket_map.keys():  # if it's one of the right brackets\n                if not stack or stack[-1] != bracket_map[char]:\n                    return False\n                stack.pop()\n        \n        return not stack  # valid if stack is empty at the end"}
{"task_id": "OOP/11", "completion": "class VDPT:\n    def valid_parentheses(self, n):\n        def generate(p, left, right):\n            if left == n and right == n:\n                result.append(p)\n                return\n            if left < n:\n                generate(p + '(', left + 1, right)\n            if right < left:\n                generate(p + ')', left, right + 1)\n\n        result = []\n        generate('', 0, 0)\n        for combination in result:\n            print(combination)"}
{"task_id": "OOP/12", "completion": "class NLAR:\n    def new_length_removal(self, nums, val):\n        original_length = len(nums)\n        nums[:] = [num for num in nums if num != val]\n        new_length = len(nums)\n        return new_length"}
{"task_id": "OOP/13", "completion": "class FMIS:\n    def find_matching_items(self, haystack: str, needle: str) -> int:\n        return haystack.find(needle)"}
{"task_id": "OOP/14", "completion": "class LVPSS:\n    def long_valid_substring(self, s: str) -> int:\n        max_length = 0\n        stack = [-1]\n        \n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_length = max(max_length, i - stack[-1])\n        \n        return max_length"}
{"task_id": "OOP/15", "completion": "class FTGV:\n    def find_target_value(self, arr, target):\n        left, right = 0, len(arr)\n        \n        while left < right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left"}
{"task_id": "OOP/16", "completion": "class FSAEP:\n    pass\n\nclass LVPSS:\n    def finding_positions(self, nums, target):\n        def find_start(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] < target:\n                    left = mid + 1\n                elif nums[mid] > target:\n                    right = mid - 1\n                else:\n                    if mid == 0 or nums[mid - 1] != target:\n                        return mid\n                    right = mid - 1\n            return -1\n\n        def find_end(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] < target:\n                    left = mid + 1\n                elif nums[mid] > target:\n                    right = mid - 1\n                else:\n                    if mid == len(nums) - 1 or nums[mid + 1] != target:\n                        return mid\n                    left = mid + 1\n            return -1\n        \n        start = find_start(nums, target)\n        end = find_end(nums, target)\n        return [start, end] if start != -1 else [-1, -1]"}
{"task_id": "OOP/17", "completion": "class NCBT:\n    def numeric_combination(self, candidates, target):\n        def backtrack(start, path, target):\n            if target == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    continue\n                backtrack(i, path + [candidates[i]], target - candidates[i])\n\n        result = []\n        backtrack(0, [], target)\n        return result"}
{"task_id": "OOP/18", "completion": "class TSPI:\n    def smallest_positive_integer(self, nums):\n        num_set = set(nums)\n        smallest = 1\n        \n        while smallest in num_set:\n            smallest += 1\n            \n        return smallest"}
{"task_id": "OOP/19", "completion": "class HTRW:\n    def harvest_rainwater(self, heights):\n        if not heights:\n            return 0\n        \n        left_max = [0] * len(heights)\n        right_max = [0] * len(heights)\n\n        left_max[0] = heights[0]\n        for i in range(1, len(heights)):\n            left_max[i] = max(left_max[i - 1], heights[i])\n\n        right_max[len(heights) - 1] = heights[len(heights) - 1]\n        for i in range(len(heights) - 2, -1, -1):\n            right_max[i] = max(right_max[i + 1], heights[i])\n\n        water_trapped = 0\n        for i in range(len(heights)):\n            water_trapped += min(left_max[i], right_max[i]) - heights[i]\n\n        return water_trapped"}
{"task_id": "OOP/20", "completion": "class STFM:\n    def string_form(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        # Initialize the result array to store the result of each digit multiplication\n        result = [0] * (len(num1) + len(num2))\n        \n        # Reverse both strings to facilitate multiplication from the least significant digit\n        num1, num2 = num1[::-1], num2[::-1]\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                # Multiply the digits\n                digit_product = int(num1[i]) * int(num2[j])\n                # Add to the result array at the correct position\n                result[i + j] += digit_product\n                # Handle carry over\n                result[i + j + 1] += result[i + j] // 10\n                result[i + j] %= 10\n        \n        # Remove leading zeros and convert result to string\n        while len(result) > 1 and result[-1] == 0:\n            result.pop()\n        \n        # Convert the result array back to string\n        return ''.join(map(str, result[::-1]))"}
{"task_id": "OOP/21", "completion": "class PMTTN:\n    def permutation(self, nums):\n        result = []\n        self._backtrack(nums, [], result)\n        return result\n\n    def _backtrack(self, nums, path, result):\n        if len(path) == len(nums):\n            result.append(path)\n            return\n        for i in range(len(nums)):\n            if nums[i] in path:\n                continue\n            self._backtrack(nums, path + [nums[i]], result)"}
{"task_id": "OOP/22", "completion": "class UQPTT:\n    def unique_permutations(self, nums):\n        result = []\n        nums.sort()\n        self._backtrack(result, [], nums, [False] * len(nums))\n        return result\n\n    def _backtrack(self, result, temp_list, nums, used):\n        if len(temp_list) == len(nums):\n            result.append(temp_list[:])\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]):\n                continue\n            used[i] = True\n            temp_list.append(nums[i])\n            self._backtrack(result, temp_list, nums, used)\n            used[i] = False\n            temp_list.pop()"}
{"task_id": "OOP/23", "completion": "class RTICW:\n    def rotate_image_clockwise(self, matrix):\n        n = len(matrix)\n        # Transpose the matrix\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        # Reverse each row\n        for i in range(n):\n            matrix[i].reverse()\n        return matrix"}
{"task_id": "OOP/24", "completion": "class AAGM:\n    def anagram(self, strings):\n        anagrams = {}\n        for s in strings:\n            key = ''.join(sorted(s))\n            if key in anagrams:\n                anagrams[key].append(s)\n            else:\n                anagrams[key] = [s]\n        return list(anagrams.values())"}
{"task_id": "OOP/25", "completion": "class PFTN:\n    def power_function(self, x, n):\n        return x ** n"}
{"task_id": "OOP/26", "completion": "class FDSB:\n    def find_subarray(self, nums):\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in nums:\n            current_sum += num\n            if current_sum > max_sum:\n                max_sum = current_sum\n            if current_sum < 0:\n                current_sum = 0\n        return max_sum"}
{"task_id": "OOP/27", "completion": "class CWSO:\n    def clockwise_spiral_order(self, matrix):\n        if not matrix or not matrix[0]:\n            return []\n        \n        result = []\n        top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n        \n        return result"}
{"task_id": "OOP/28", "completion": "class MMJL:\n    def maximum_jump_length(self, nums):\n        max_reachable = 0\n        for i in range(len(nums)):\n            if i > max_reachable:\n                return False\n            max_reachable = max(max_reachable, i + nums[i])\n            if max_reachable >= len(nums) - 1:\n                return True\n        return False"}
{"task_id": "OOP/29", "completion": "class MOLI:\n    def merge_overlapping_intervals(self, intervals):\n        if not intervals:\n            return []\n        \n        # Sort the intervals by the start time\n        intervals.sort(key=lambda x: x[0])\n        \n        merged = [intervals[0]]\n        \n        for current in intervals[1:]:\n            last_merged = merged[-1]\n            \n            # If the current interval overlaps with the last merged one, merge them\n            if current[0] <= last_merged[1]:\n                last_merged[1] = max(last_merged[1], current[1])\n            else:\n                merged.append(current)\n        \n        return merged"}
{"task_id": "OOP/30", "completion": "class STANOL:\n    def __init__(self, intervals=None):\n        if intervals is None:\n            intervals = []\n        self.intervals = sorted(intervals, key=lambda x: x[0])\n\n    def sorted_non_overlapping(self, new_interval):\n        self.intervals.append(new_interval)\n        self.intervals.sort(key=lambda x: x[0])\n        \n        merged = []\n        for interval in self.intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        \n        self.intervals = merged\n        return self.intervals"}
{"task_id": "OOP/31", "completion": "class WDLH:\n    def word_length(self, s: str) -> int:\n        # Strip the string to remove leading and trailing spaces\n        s = s.strip()\n        # Split the string into words\n        words = s.split()\n        # Return the length of the last word\n        return len(words[-1]) if words else 0"}
{"task_id": "OOP/32", "completion": "class STP:\n    def shortest_path(self, grid):\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n        return dp[m - 1][n - 1]"}
{"task_id": "OOP/33", "completion": "class NNTI:\n    def non_negative_integer(self, digits):\n        # Start from the end of the array and add one\n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        # If all digits were 9, we need an extra digit in the front\n        return [1] + digits"}
{"task_id": "OOP/34", "completion": "class BASTI:\n    def binary_string(self, a: str, b: str) -> str:\n        sum_decimal = int(a, 2) + int(b, 2)\n        return bin(sum_decimal)[2:]"}
{"task_id": "OOP/35", "completion": "class CRTP:\n    def climb_rooftop(self, n):\n        if n <= 1:\n            return 1\n        return self.climb_rooftop(n - 1) + self.climb_rooftop(n - 2)\n\nclass Climber(CRTP):\n    pass\n\n# Example usage:\n# climber = Climber()\n# print(climber.climb_rooftop(5))  # Output: 8"}
{"task_id": "OOP/36", "completion": "class TAFER:\n    def trans_fomer(self, word1, word2):\n        m = len(word1)\n        n = len(word2)\n        \n        # Create a (m+1) x (n+1) matrix\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        # Initialize the first row and column\n        for i in range(m + 1):\n            dp[i][0] = i  # cost of deleting all characters from word1\n        for j in range(n + 1):\n            dp[0][j] = j  # cost of inserting all characters to form word2\n        \n        # Fill the matrix\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]  # characters are the same\n                else:\n                    dp[i][j] = min(\n                        dp[i - 1][j] + 1,     # Deletion\n                        dp[i][j - 1] + 1,     # Insertion\n                        dp[i - 1][j - 1] + 1  # Replacement\n                    )\n        \n        return dp[m][n]"}
{"task_id": "OOP/37", "completion": "class STEZ:\n    def element_setting_zero(self, matrix):\n        if not matrix or not matrix[0]:\n            return\n        \n        rows, cols = len(matrix), len(matrix[0])\n        zero_rows = set()\n        zero_cols = set()\n\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    zero_rows.add(i)\n                    zero_cols.add(j)\n\n        for row in zero_rows:\n            for j in range(cols):\n                matrix[row][j] = 0\n\n        for col in zero_cols:\n            for i in range(rows):\n                matrix[i][col] = 0"}
{"task_id": "OOP/38", "completion": "class GYHT:\n    def YangHui_Triangle(self, numRows):\n        triangle = []\n        for i in range(numRows):\n            row = [1] * (i + 1)\n            for j in range(1, i):\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n            triangle.append(row)\n        return triangle"}
{"task_id": "OOP/39", "completion": "class FTMPA:\n    def Minimum_Path(self, triangle):\n        if not triangle:\n            return 0\n\n        # Start from the second to last row and move upward\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(len(triangle[row])):\n                # Update the current cell with the minimum path sum\n                triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n\n        # The top element now contains the minimum path sum\n        return triangle[0][0]"}
{"task_id": "OOP/40", "completion": "class CMP:\n    def Calculate_Maximum_Profit(self, prices):\n        if not prices:\n            return 0\n\n        n = len(prices)\n        if n < 2:\n            return 0\n\n        # Array to store the maximum profit up to day i with one transaction\n        first_transaction_profits = [0] * n\n        min_price = prices[0]\n\n        for i in range(1, n):\n            min_price = min(min_price, prices[i])\n            first_transaction_profits[i] = max(first_transaction_profits[i - 1], prices[i] - min_price)\n\n        # Array to store the maximum profit from day i to the end with one transaction\n        second_transaction_profits = [0] * n\n        max_price = prices[-1]\n\n        for i in range(n - 2, -1, -1):\n            max_price = max(max_price, prices[i])\n            second_transaction_profits[i] = max(second_transaction_profits[i + 1], max_price - prices[i])\n\n        max_profit = 0\n        for i in range(n):\n            max_profit = max(max_profit, first_transaction_profits[i] + second_transaction_profits[i])\n\n        return max_profit"}
{"task_id": "OOP/41", "completion": "class FTLOTLS:\n    def Longest_Sequence(self, nums):\n        if not nums:\n            return 0\n        \n        num_set = set(nums)\n        longest_sequence = 0\n        \n        for num in num_set:\n            if num - 1 not in num_set:\n                current_num = num\n                current_streak = 1\n                \n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_streak += 1\n                \n                longest_sequence = max(longest_sequence, current_streak)\n        \n        return longest_sequence"}
{"task_id": "OOP/42", "completion": "class AF:\n    def Area_Fill(self, board):\n        if not board:\n            return\n        \n        rows, cols = len(board), len(board[0])\n        \n        def bfs(r, c):\n            queue = [(r, c)]\n            board[r][c] = 'B'  # Mark as visited\n\n            while queue:\n                x, y = queue.pop(0)\n                directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < rows and 0 <= ny < cols and board[nx][ny] == 'O':\n                        board[nx][ny] = 'B'\n                        queue.append((nx, ny))\n\n        for r in range(rows):\n            for c in range(cols):\n                if (r in [0, rows - 1] or c in [0, cols - 1]) and board[r][c] == 'O':\n                    bfs(r, c)\n\n        for r in range(rows):\n            for c in range(cols):\n                if board[r][c] == 'O':\n                    board[r][c] = 'X'\n                elif board[r][c] == 'B':\n                    board[r][c] = 'O'"}
{"task_id": "OOP/43", "completion": "class SS:\n    def Split_String(self, s: str):\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n\n        def backtrack(start: int, path: list):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                substring = s[start:end]\n                if is_palindrome(substring):\n                    path.append(substring)\n                    backtrack(end, path)\n                    path.pop()\n\n        result = []\n        backtrack(0, [])\n        return result"}
{"task_id": "OOP/44", "completion": "class MNOD:\n    def is_palindrome(self, s):\n        return s == s[::-1]\n\n    def Minimum_Divisions(self, s):\n        n = len(s)\n        dp = [0] * n\n\n        for i in range(n):\n            min_cuts = i  # maximum cuts\n            for j in range(i + 1):\n                if self.is_palindrome(s[j:i + 1]):\n                    min_cuts = 0 if j == 0 else min(min_cuts, dp[j - 1] + 1)\n            dp[i] = min_cuts\n\n        return dp[n - 1]"}
{"task_id": "OOP/45", "completion": "class DSBCD:\n    def distribute_candie(self, ratings):\n        if not ratings:\n            return 0\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        # First pass: left to right\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        # Second pass: right to left\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}
{"task_id": "OOP/46", "completion": "class ITETAO:\n    def Appeared_Once(self, nums):\n        result = 0\n        for num in nums:\n            result ^= num\n        return result"}
{"task_id": "OOP/47", "completion": "class JS:\n    def Judgment_Splicing(self, s, wordDict):\n        word_set = set(wordDict)\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n                    \n        return dp[n]"}
{"task_id": "OOP/48", "completion": "class CS:\n    def __init__(self, wordDict):\n        self.wordDict = set(wordDict)\n\n    def Constructing_Sentences(self, s):\n        def backtrack(index, path):\n            if index == len(s):\n                result.append(\" \".join(path))\n                return\n            for end in range(index + 1, len(s) + 1):\n                word = s[index:end]\n                if word in self.wordDict:\n                    backtrack(end, path + [word])\n\n        result = []\n        backtrack(0, [])\n        return result"}
{"task_id": "OOP/49", "completion": "class FTMP:\n    def Most_Points(self, points):\n        if not points:\n            return 0\n\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        max_points = 1\n        n = len(points)\n\n        for i in range(n):\n            slopes = {}\n            for j in range(n):\n                if i != j:\n                    dy = points[j][1] - points[i][1]\n                    dx = points[j][0] - points[i][0]\n                    g = gcd(dy, dx)\n                    slope = (dy // g, dx // g) if g != 0 else (1, 0)\n                    slopes[slope] = slopes.get(slope, 0) + 1\n\n            if slopes:\n                max_points = max(max_points, max(slopes.values()) + 1)\n\n        return max_points"}
{"task_id": "OOP/50", "completion": "class CE:\n    def Calculating_Expressions(self, tokens):\n        stack = []\n        operators = set(['+', '-', '*', '/'])\n\n        for token in tokens:\n            if token not in operators:\n                stack.append(int(token))\n            else:\n                b = stack.pop()\n                a = stack.pop()\n\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                elif token == '/':\n                    # Python division truncates towards minus infinity, we need to truncate towards zero\n                    stack.append(int(a / b))  # Using int() to truncate towards zero\n\n        return stack[0] if stack else 0"}
{"task_id": "OOP/51", "completion": "class RWO:\n    def Reverse_Word_Order(self, s: str) -> str:\n        words = s.split()\n        reversed_words = words[::-1]\n        return ' '.join(reversed_words)"}
{"task_id": "OOP/52", "completion": "class NCS:\n    def non_empty_subarray(self, nums):\n        if not nums:\n            return 0\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            num = nums[i]\n            if num < 0:\n                max_product, min_product = min_product, max_product\n            \n            max_product = max(num, max_product * num)\n            min_product = min(num, min_product * num)\n            \n            result = max(result, max_product)\n        \n        return result"}
{"task_id": "OOP/53", "completion": "class PE:\n    def Peak_elements(self, nums):\n        if not nums:\n            return -1\n        n = len(nums)\n        if n == 1:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[n - 1] > nums[n - 2]:\n            return n - 1\n        for i in range(1, n - 1):\n            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:\n                return i\n        return -1"}
{"task_id": "OOP/54", "completion": "class TMDBAE:\n    def adjacent_elements(self, nums):\n        if len(nums) < 2:\n            return 0\n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff"}
{"task_id": "OOP/55", "completion": "class GME:\n    def get_most_elements(self, nums):\n        count = {}\n        threshold = len(nums) // 2\n        \n        for num in nums:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n            \n            if count[num] > threshold:\n                return num\n        \n        return None  # If no majority element exists"}
{"task_id": "OOP/56", "completion": "class GTNOTZ:\n    def get_trailing(self, n: int) -> int:\n        count = 0\n        i = 5\n        while n // i > 0:\n            count += n // i\n            i *= 5\n        return count"}
{"task_id": "OOP/57", "completion": "class NNI:\n    def Non_negative_integers(self, nums):\n        # Convert numbers to strings for comparison\n        nums_str = list(map(str, nums))\n        # Sort numbers based on custom comparator\n        nums_str.sort(key=lambda x: x*10, reverse=True)\n        # Join sorted numbers\n        largest_number = ''.join(nums_str)\n        # Handle the case for leading zeros\n        return largest_number if largest_number[0] != '0' else '0'"}
{"task_id": "OOP/58", "completion": "class IRSID:\n    def sequences_DNA(self, s):\n        sequences = {}\n        result = set()\n        \n        for i in range(len(s) - 9):\n            substring = s[i:i + 10]\n            if substring in sequences:\n                sequences[substring] += 1\n            else:\n                sequences[substring] = 1\n                \n            if sequences[substring] == 2:  # We only want duplicates\n                result.add(substring)\n        \n        return list(result)"}
{"task_id": "OOP/59", "completion": "class ERTTR:\n    def element_rotates(self, nums, k):\n        n = len(nums)\n        if n == 0:\n            return nums\n        k = k % n\n        return nums[-k:] + nums[:-k]"}
{"task_id": "OOP/60", "completion": "class ITBB:\n    def Invert_the_binary_bits(self, n: int) -> int:\n        result = 0\n        for i in range(32):\n            result = (result << 1) | (n & 1)\n            n >>= 1\n        return result"}
{"task_id": "OOP/61", "completion": "class RTN:\n    def Hamming_weight(self, binary_string):\n        return binary_string.count('1')"}
{"task_id": "OOP/62", "completion": "class CTNOI:\n    def __init__(self, grid):\n        self.grid = grid\n        self.rows = len(grid)\n        self.cols = len(grid[0]) if self.rows > 0 else 0\n\n    def number_islands(self):\n        if not self.grid:\n            return 0\n\n        visited = [[False for _ in range(self.cols)] for _ in range(self.rows)]\n        island_count = 0\n\n        def dfs(r, c):\n            if r < 0 or c < 0 or r >= self.rows or c >= self.cols:\n                return\n            if self.grid[r][c] == '0' or visited[r][c]:\n                return\n            visited[r][c] = True\n            dfs(r + 1, c)\n            dfs(r - 1, c)\n            dfs(r, c + 1)\n            dfs(r, c - 1)\n\n        for i in range(self.rows):\n            for j in range(self.cols):\n                if self.grid[i][j] == '1' and not visited[i][j]:\n                    island_count += 1\n                    dfs(i, j)\n\n        return island_count"}
{"task_id": "OOP/63", "completion": "class DABA:\n    def Digits_bitwise(self, left: int, right: int) -> int:\n        while left < right:\n            right &= right - 1\n        return right"}
{"task_id": "OOP/64", "completion": "class RV:\n    def Return_value(self, n):\n        if n <= 2:\n            return 0\n        prime_count = 0\n        is_prime = [True] * n\n        is_prime[0] = is_prime[1] = False\n        \n        for i in range(2, int(n**0.5) + 1):\n            if is_prime[i]:\n                for j in range(i * i, n, i):\n                    is_prime[j] = False\n        \n        prime_count = sum(is_prime)\n        return prime_count"}
{"task_id": "OOP/65", "completion": "class DIIII:\n    def isomorphic(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        s_to_t = {}\n        t_to_s = {}\n\n        for char_s, char_t in zip(s, t):\n            if char_s in s_to_t:\n                if s_to_t[char_s] != char_t:\n                    return False\n            else:\n                s_to_t[char_s] = char_t\n\n            if char_t in t_to_s:\n                if t_to_s[char_t] != char_s:\n                    return False\n            else:\n                t_to_s[char_t] = char_s\n\n        return True"}
{"task_id": "OOP/66", "completion": "class FTA:\n    def Find_the_array(self, nums, target):\n        n = len(nums)\n        min_length = float('inf')\n        left = 0\n        current_sum = 0\n\n        for right in range(n):\n            current_sum += nums[right]\n            while current_sum >= target:\n                min_length = min(min_length, right - left + 1)\n                current_sum -= nums[left]\n                left += 1\n\n        return min_length if min_length != float('inf') else 0"}
{"task_id": "OOP/67", "completion": "class STPD:\n    def Shortest_Palindrome(self, s: str) -> str:\n        if not s:\n            return \"\"\n        \n        # Concatenate string with a separator and its reverse\n        concat = s + \"#\" + s[::-1]\n        n = len(concat)\n        \n        # Build the KMP table\n        lps = [0] * n\n        j = 0\n        \n        for i in range(1, n):\n            while j > 0 and concat[i] != concat[j]:\n                j = lps[j - 1]\n            if concat[i] == concat[j]:\n                j += 1\n            lps[i] = j\n        \n        # The length of the longest palindromic suffix\n        longest_palindrome_suffix = lps[-1]\n        \n        # Add the necessary characters in front of the original string\n        to_add = s[longest_palindrome_suffix:][::-1]\n        \n        return to_add + s"}
{"task_id": "OOP/68", "completion": "class RTLE:\n    def largest_element(self, nums, k):\n        if not nums or k <= 0 or k > len(nums):\n            return None\n        nums.sort(reverse=True)\n        return nums[k - 1]"}
{"task_id": "OOP/69", "completion": "class GTAC:\n    def additive_combination(self, k, n):\n        def backtrack(start, combination):\n            if len(combination) == k and sum(combination) == n:\n                result.append(list(combination))\n                return\n            for i in range(start, 10):\n                combination.append(i)\n                backtrack(i + 1, combination)\n                combination.pop()\n\n        result = []\n        backtrack(1, [])\n        return result"}
{"task_id": "OOP/70", "completion": "class JTA:\n    def judging_the_array(self, nums):\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False"}
{"task_id": "OOP/71", "completion": "class JI:\n    def Judgment_Index(self, nums, k):\n        index_map = {}\n        for i, num in enumerate(nums):\n            if num in index_map and abs(i - index_map[num]) <= k:\n                return True\n            index_map[num] = i\n        return False"}
{"task_id": "OOP/72", "completion": "class AC:\n    def Array_conditions(self, nums, indexDiff, valueDiff):\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, min(i + indexDiff + 1, n)):\n                if abs(nums[i] - nums[j]) <= valueDiff:\n                    return True\n        return False"}
{"task_id": "OOP/73", "completion": "class FTLS:\n    def largest_square(self, matrix):\n        if not matrix or not matrix[0]:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        dp = [[0] * cols for _ in range(rows)]\n        max_square_length = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                    max_square_length = max(max_square_length, dp[i][j])\n        \n        return max_square_length * max_square_length"}
{"task_id": "OOP/74", "completion": "class CTMA:\n    def matrix_area(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n        # Calculate the area of the first rectangle\n        area1 = (ax2 - ax1) * (ay2 - ay1)\n        \n        # Calculate the area of the second rectangle\n        area2 = (bx2 - bx1) * (by2 - by1)\n        \n        # Calculate the overlap rectangle coordinates\n        overlap_x1 = max(ax1, bx1)\n        overlap_y1 = max(ay1, by1)\n        overlap_x2 = min(ax2, bx2)\n        overlap_y2 = min(ay2, by2)\n        \n        # Calculate the area of the overlap\n        overlap_area = 0\n        if overlap_x1 < overlap_x2 and overlap_y1 < overlap_y2:\n            overlap_area = (overlap_x2 - overlap_x1) * (overlap_y2 - overlap_y1)\n        \n        # Compute the total area covered by both rectangles\n        total_area = area1 + area2 - overlap_area\n        \n        return total_area"}
{"task_id": "OOP/75", "completion": "class TAC:\n    def The_array_contains(self, nums):\n        if not nums:\n            return []\n        \n        result = []\n        start = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1] + 1:\n                if start == nums[i - 1]:\n                    result.append(str(start))\n                else:\n                    result.append(f\"{start}->{nums[i - 1]}\")\n                start = nums[i]\n\n        if start == nums[-1]:\n            result.append(str(start))\n        else:\n            result.append(f\"{start}->{nums[-1]}\")\n\n        return result"}
{"task_id": "OOP/76", "completion": "class GTAC:\n    def array_count(self, nums):\n        if not nums:\n            return []\n\n        n = len(nums)\n        count_threshold = n // 3\n        count_map = {}\n        \n        # Count occurrences of each number\n        for num in nums:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n        \n        # Collect numbers that occur more than n/3 times\n        result = [num for num, count in count_map.items() if count > count_threshold]\n        return result"}
