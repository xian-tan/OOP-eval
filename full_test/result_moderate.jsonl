{"task_id": "OOP/0", "completion": "class ULYNB:\n    def __init__(self, n):\n        self.n = n\n    \n    def private_ugly_number(self):\n        if self.n <= 0:\n            return 0\n        ugly_numbers = [1]\n        i2 = i3 = i5 = 0\n        \n        while len(ugly_numbers) < self.n:\n            next_ugly = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n            ugly_numbers.append(next_ugly)\n            \n            if next_ugly == ugly_numbers[i2] * 2:\n                i2 += 1\n            if next_ugly == ugly_numbers[i3] * 3:\n                i3 += 1\n            if next_ugly == ugly_numbers[i5] * 5:\n                i5 += 1\n        \n        return ugly_numbers[-1]\n    \n    def public_ugly_number(self):\n        return self.private_ugly_number()"}
{"task_id": "OOP/1", "completion": "class NAR:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Number_array(self, n):\n        return [i for i in range(n + 1) if i not in self.nums]\n\n    def public_Number_array(self, n):\n        return self.__private_Number_array(n)"}
{"task_id": "OOP/2", "completion": "class ERS:\n    def __init__(self, num):\n        self.num = num\n\n    def private_rep(self):\n        if self.num < 0:\n            return \"Negative numbers not supported\"\n        if self.num == 0:\n            return \"Zero\"\n        \n        units = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(n):\n            if n < 10:\n                return units[n]\n            elif n < 20:\n                return teens[n - 10]\n            elif n < 100:\n                return tens[n // 10] + ((\" \" + units[n % 10]) if n % 10 != 0 else \"\")\n            elif n < 1000:\n                return units[n // 100] + \" Hundred\" + ((\" \" + helper(n % 100)) if n % 100 != 0 else \"\")\n            \n        res = \"\"\n        i = 0\n        while self.num > 0:\n            current = self.num % 1000\n            if current != 0:\n                res = helper(current) + \" \" + thousands[i] + \" \" + res\n            self.num //= 1000\n            i += 1\n        \n        return res.strip()\n\n    def public_rep(self):\n        return self.private_rep()"}
{"task_id": "OOP/3", "completion": "class PCT:\n    def __init__(self, citations):\n        self.citations = citations\n\n    def __private_Paper_cited(self):\n        sorted_citations = sorted(self.citations, reverse=True)\n        h_index = 0\n        for i, citation in enumerate(sorted_citations):\n            if citation >= i + 1:\n                h_index = i + 1\n            else:\n                break\n        return h_index\n\n    def public_Paper_cited(self):\n        return self.__private_Paper_cited()"}
{"task_id": "OOP/4", "completion": "class AOD:\n    def __init__(self, citations):\n        self.citations = citations\n\n    def __private_Paper_cited(self):\n        n = len(self.citations)\n        for i in range(n):\n            if self.citations[i] >= n - i:\n                return n - i\n        return 0\n\n    def public_ascend_order(self):\n        return self.__private_Paper_cited()"}
{"task_id": "OOP/5", "completion": "class MQT:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Minimum_quantity(self):\n        if self.n < 0:\n            return float('inf')\n        elif self.n == 0:\n            return 0\n        \n        perfect_squares = []\n        i = 1\n        while i * i <= self.n:\n            perfect_squares.append(i * i)\n            i += 1\n            \n        dp = [float('inf')] * (self.n + 1)\n        dp[0] = 0\n        \n        for square in perfect_squares:\n            for j in range(square, self.n + 1):\n                dp[j] = min(dp[j], dp[j - square] + 1)\n                \n        return dp[self.n]\n\n    def public_Minimum_quantity(self):\n        return self.private_Minimum_quantity()"}
{"task_id": "OOP/6", "completion": "class BOT:\n    def __init__(self, num: str, target: int):\n        self.num = num\n        self.target = target\n\n    def private_Binary_operator(self):\n        def backtrack(index: int, path: str, prev_operand: int, current: int):\n            if index == len(self.num):\n                if current == self.target:\n                    results.append(path)\n                return\n            \n            for i in range(index, len(self.num)):\n                current_num_str = self.num[index:i+1]\n                if len(current_num_str) > 1 and current_num_str[0] == '0':\n                    break\n                \n                current_num = int(current_num_str)\n                \n                if index == 0:\n                    backtrack(i + 1, current_num_str, current_num, current_num)\n                else:\n                    backtrack(i + 1, path + '+' + current_num_str, current_num, current + current_num)\n                    backtrack(i + 1, path + '-' + current_num_str, -current_num, current - current_num)\n                    backtrack(i + 1, path + '*' + current_num_str, prev_operand * current_num, (current - prev_operand) + (prev_operand * current_num))\n        \n        results = []\n        backtrack(0, '', 0, 0)\n        return results\n\n    def public_Binary_operator(self):\n        return self.private_Binary_operator()"}
{"task_id": "OOP/7", "completion": "class ROE:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_relative_order(self):\n        non_zero = [num for num in self.nums if num != 0]\n        zero_count = self.nums.count(0)\n        return non_zero + [0] * zero_count\n\n    def public_relative_order(self):\n        return self.__private_relative_order()"}
{"task_id": "OOP/8", "completion": "class NDC:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Number_duplicates(self):\n        slow = self.nums[0]\n        fast = self.nums[0]\n\n        while True:\n            slow = self.nums[slow]\n            fast = self.nums[self.nums[fast]]\n            if slow == fast:\n                break\n\n        slow = self.nums[0]\n        while slow != fast:\n            slow = self.nums[slow]\n            fast = self.nums[fast]\n\n        return slow\n\n    def public_Number_duplicates(self):\n        return self.__private_Number_duplicates()"}
{"task_id": "OOP/9", "completion": "class LSQ:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Longest_subsequence(self):\n        if not self.nums:\n            return 0\n        dp = [1] * len(self.nums)\n        for i in range(1, len(self.nums)):\n            for j in range(i):\n                if self.nums[i] > self.nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    def public_Longest_subsequence(self):\n        return self.__private_Longest_subsequence()"}
{"task_id": "OOP/10", "completion": "class VSR:\n    def __init__(self, s: str):\n        self.s = s\n\n    def private_Valid_string(self):\n        def is_valid(string):\n            counter = 0\n            for char in string:\n                if char == '(':\n                    counter += 1\n                elif char == ')':\n                    counter -= 1\n                if counter < 0:\n                    return False\n            return counter == 0\n\n        def dfs(string, start, left_count, right_count, ans):\n            if left_count == 0 and right_count == 0:\n                if is_valid(string):\n                    ans.add(string)\n                return\n\n            for i in range(start, len(string)):\n                if i > start and string[i] == string[i - 1]:\n                    continue\n                if left_count > 0 and string[i] == '(':\n                    dfs(string[:i] + string[i + 1:], i, left_count - 1, right_count, ans)\n                if right_count > 0 and string[i] == ')':\n                    dfs(string[:i] + string[i + 1:], i, left_count, right_count - 1, ans)\n\n        left_count = right_count = 0\n        for char in self.s:\n            if char == '(':\n                left_count += 1\n            elif char == ')':\n                if left_count > 0:\n                    left_count -= 1\n                else:\n                    right_count += 1\n\n        ans = set()\n        dfs(self.s, 0, left_count, right_count, ans)\n        return list(ans)\n\n    def public_Valid_string(self):\n        return self.private_Valid_string()"}
{"task_id": "OOP/11", "completion": "class ANB:\n    def __init__(self, s):\n        self.s = s\n\n    def private_Accumulated_number(self):\n        n = len(self.s)\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                num1 = self.s[:i]\n                num2 = self.s[i:j]\n                if num1[0] == '0' and len(num1) > 1:\n                    continue\n                if num2[0] == '0' and len(num2) > 1:\n                    continue\n                \n                sequence = [int(num1), int(num2)]\n                idx = j\n                \n                while idx < n:\n                    next_num = sequence[-1] + sequence[-2]\n                    next_num_str = str(next_num)\n                    next_num_len = len(next_num_str)\n                    \n                    if idx + next_num_len > n or self.s[idx:idx + next_num_len] != next_num_str:\n                        break\n                    \n                    sequence.append(next_num)\n                    idx += next_num_len\n                \n                if idx == n and len(sequence) >= 3:\n                    return True\n        return False\n\n    def public_Accumulated_number(self):\n        return self.private_Accumulated_number()"}
{"task_id": "OOP/12", "completion": "class MCS:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Maximum_coins(self, nums):\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        for length in range(1, n - 1):\n            for left in range(1, n - length):\n                right = left + length - 1\n                for i in range(left, right + 1):\n                    dp[left][right] = max(dp[left][right], \n                                           dp[left][i - 1] + dp[i + 1][right] + nums[left - 1] * nums[i] * nums[right + 1])\n        \n        return dp[1][n - 2]\n\n    def public_Maximum_coins(self):\n        return self.private_Maximum_coins(self.nums)"}
{"task_id": "OOP/13", "completion": "class SNE:\n    def __init__(self, n, primes):\n        self.n = n\n        self.primes = primes\n    \n    def __private_Super_Number(self):\n        heap = []\n        ugly_numbers = {1}\n        for prime in self.primes:\n            heap.append(prime)\n        \n        result = 1\n        for _ in range(self.n):\n            result = heap[0]\n            if result in ugly_numbers:\n                ugly_numbers.remove(result)\n            for prime in self.primes:\n                new_ugly = result * prime\n                if new_ugly not in ugly_numbers:\n                    ugly_numbers.add(new_ugly)\n                    heap.append(new_ugly)\n            heap.sort()\n            del heap[0]\n        \n        return result\n    \n    def public_Super_Number(self):\n        return self.__private_Super_Number()"}
{"task_id": "OOP/14", "completion": "class IAA:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Integer_array(self):\n        counts = []\n        for i in range(len(self.nums)):\n            count = sum(1 for x in self.nums[i+1:] if x < self.nums[i])\n            counts.append(count)\n        return counts\n\n    def public_Integer_array(self):\n        return self.__private_Integer_array()"}
{"task_id": "OOP/15", "completion": "class DMM:\n    def __init__(self, s):\n        self.s = s\n\n    def __private_Dictionary_minimum(self):\n        unique_chars = sorted(set(self.s))\n        return ''.join(unique_chars)\n\n    def public_Dictionary_minimum(self):\n        return self.__private_Dictionary_minimum()"}
{"task_id": "OOP/16", "completion": "class CLS:\n    def __init__(self, words):\n        self.words = words\n\n    def __private_Common_letters(self):\n        max_length = 0\n        for i in range(len(self.words)):\n            for j in range(i + 1, len(self.words)):\n                max_length = max(max_length, len(self.words[i]) * len(self.words[j]))\n        return max_length\n\n    def public_Common_letters(self):\n        return self.__private_Common_letters()"}
{"task_id": "OOP/17", "completion": "class ROD:\n    def __init__(self, nums1, nums2, k):\n        self.nums1 = nums1\n        self.nums2 = nums2\n        self.k = k\n\n    def private_relative_order(self):\n        m, n = len(self.nums1), len(self.nums2)\n        result = []\n        \n        for i in range(max(0, self.k - n), min(m, self.k) + 1):\n            j = self.k - i\n            if j > n or j < 0:\n                continue\n            temp1 = self.max_number(self.nums1, i)\n            temp2 = self.max_number(self.nums2, j)\n            merged = self.merge(temp1, temp2)\n            result = max(result, merged)\n        \n        return result\n\n    def max_number(self, nums, length):\n        drop = len(nums) - length\n        stack = []\n        \n        for num in nums:\n            while drop and stack and stack[-1] < num:\n                stack.pop()\n                drop -= 1\n            stack.append(num)\n        \n        return stack[:length]\n\n    def merge(self, list1, list2):\n        result = []\n        while list1 or list2:\n            if list1 > list2:\n                result.append(list1.pop(0))\n            else:\n                result.append(list2.pop(0))\n        return result\n\n    def public_relative_order(self):\n        return self.private_relative_order()"}
{"task_id": "OOP/18", "completion": "class TAU:\n    def __init__(self, coins, amount):\n        self.coins = coins\n        self.amount = amount\n\n    def __private_Total_amount(self):\n        dp = [float('inf')] * (self.amount + 1)\n        dp[0] = 0\n        for coin in self.coins:\n            for x in range(coin, self.amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        return dp[self.amount] if dp[self.amount] != float('inf') else -1\n\n    def public_Total_amount(self):\n        return self.__private_Total_amount()"}
{"task_id": "OOP/19", "completion": "class ROR:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Rearranged_order(self):\n        for i in range(1, len(self.nums), 2):\n            if i < len(self.nums) - 1 and self.nums[i] <= self.nums[i + 1]:\n                self.nums[i], self.nums[i + 1] = self.nums[i + 1], self.nums[i]\n            if i > 0 and self.nums[i] >= self.nums[i - 1]:\n                self.nums[i], self.nums[i - 1] = self.nums[i - 1], self.nums[i]\n\n    def public_Rearranged_order(self):\n        self.__private_Rearranged_order()\n        return self.nums"}
{"task_id": "OOP/20", "completion": "class IAN:\n    def __init__(self, nums, lower, upper):\n        self.nums = nums\n        self.lower = lower\n        self.upper = upper\n\n    def private_Interval_and(self):\n        count = 0\n        n = len(self.nums)\n        for i in range(n):\n            current_sum = 0\n            for j in range(i, n):\n                current_sum += self.nums[j]\n                if self.lower <= current_sum <= self.upper:\n                    count += 1\n        return count\n\n    def public_Interval_and(self):\n        return self.private_Interval_and()"}
{"task_id": "OOP/21", "completion": "class LIM:\n    def __init__(self, matrix):\n        self.matrix = matrix\n\n    def __private_Longest_Incremental(self, x, y, prev_value, memo):\n        if (x < 0 or x >= len(self.matrix) or \n            y < 0 or y >= len(self.matrix[0]) or \n            self.matrix[x][y] <= prev_value):\n            return 0\n        \n        if (x, y) in memo:\n            return memo[(x, y)]\n        \n        length = 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            length = max(length, 1 + self.__private_Longest_Incremental(x + dx, y + dy, self.matrix[x][y], memo))\n\n        memo[(x, y)] = length\n        return length\n\n    def public_Longest_Incremental(self):\n        if not self.matrix or not self.matrix[0]:\n            return 0\n        \n        longest = 0\n        memo = {}\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[0])):\n                longest = max(longest, self.__private_Longest_Incremental(i, j, float('-inf'), memo))\n        \n        return longest"}
{"task_id": "OOP/22", "completion": "class NDT:\n    def __init__(self, nums, n):\n        self.nums = nums\n        self.n = n\n\n    def private_Number_digits(self):\n        max_reachable = 0\n        count = 0\n        for num in self.nums:\n            while max_reachable + 1 < num and max_reachable < self.n:\n                count += 1\n                max_reachable += max_reachable + 1\n            max_reachable += num\n            if max_reachable >= self.n:\n                break\n        while max_reachable < self.n:\n            count += 1\n            max_reachable += max_reachable + 1\n        return count\n\n    def public_Number_digits(self):\n        return self.private_Number_digits()"}
{"task_id": "OOP/23", "completion": "class LSU:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Longest_subsequence(self):\n        n = len(self.nums)\n        if n < 3:\n            return False\n        min1 = float('inf')\n        min2 = float('inf')\n        for num in self.nums:\n            if num <= min1:\n                min1 = num\n            elif num <= min2:\n                min2 = num\n            else:\n                return True\n        return False\n\n    def public_Longest_subsequence(self):\n        return self.private_Longest_subsequence()"}
{"task_id": "OOP/24", "completion": "class CVA:\n    def __init__(self, distance):\n        self.distance = distance\n\n    def private_Counterclockwise_variation(self):\n        x, y = 0, 0\n        visited = set()\n        visited.add((x, y))\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Up, Right, Down, Left\n        dir_index = 0\n\n        for dist in self.distance:\n            for _ in range(dist):\n                x += directions[dir_index][0]\n                y += directions[dir_index][1]\n                if (x, y) in visited:\n                    return True\n                visited.add((x, y))\n            dir_index = (dir_index + 1) % 4  # Change direction counterclockwise\n\n        return False\n\n    def public_Counterclockwise_variation(self):\n        return self.private_Counterclockwise_variation()"}
{"task_id": "OOP/25", "completion": "class USI:\n    def __init__(self, words):\n        self.words = words\n\n    def __private_Unique_String(self):\n        unique_palindromes = []\n        seen = set()\n        \n        for word in self.words:\n            if word not in seen and word == word[::-1]:\n                unique_palindromes.append(word)\n                seen.add(word)\n        \n        return unique_palindromes\n\n    def public_Unique_String(self):\n        return self.__private_Unique_String()"}
{"task_id": "OOP/26", "completion": "class PMM:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Product_maximization(self):\n        if self.n < 2:\n            return 0\n        \n        # Decompose n into k parts and maximize the product\n        max_product = 0\n        for i in range(2, self.n + 1):\n            if self.n % i == 0:\n                product = (self.n // i) ** i\n                if product > max_product:\n                    max_product = product\n        \n        return max_product\n\n    def public_Product_maximization(self):\n        return self.private_Product_maximization()"}
{"task_id": "OOP/27", "completion": "class RSI:\n    def __init__(self, s):\n        self.s = s\n\n    def __private_Result_String(self):\n        vowels = 'aeiouAEIOU'\n        s_list = list(self.s)\n        vowels_in_s = [char for char in s_list if char in vowels][::-1]\n        j = 0\n        \n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowels_in_s[j]\n                j += 1\n        \n        return ''.join(s_list)\n\n    def public_Result_String(self):\n        return self.__private_Result_String()"}
{"task_id": "OOP/28", "completion": "class AOER:\n    def __init__(self, nums, k):\n        self.nums = nums\n        self.k = k\n\n    def private_Any_order(self):\n        from collections import Counter\n        count = Counter(self.nums)\n        return [item for item, freq in count.most_common(self.k)]\n\n    def public_Any_order(self):\n        return self.private_Any_order()"}
{"task_id": "OOP/29", "completion": "class TIE:\n    def __init__(self, nums1, nums2):\n        self.nums1 = nums1\n        self.nums2 = nums2\n\n    def private_Their_intersection(self):\n        return list(set(self.nums1) & set(self.nums2))\n\n    def public_Their_intersection(self):\n        return self.private_Their_intersection()"}
{"task_id": "OOP/30", "completion": "class ORU:\n    def __init__(self, nums1, nums2):\n        self.nums1 = nums1\n        self.nums2 = nums2\n\n    def private_Order_results(self):\n        from collections import Counter\n        \n        count1 = Counter(self.nums1)\n        count2 = Counter(self.nums2)\n        \n        intersection = []\n        for num in count1:\n            if num in count2:\n                min_count = min(count1[num], count2[num])\n                intersection.extend([num] * min_count)\n        \n        return intersection\n\n    def public_Order_results(self):\n        return self.private_Order_results()"}
{"task_id": "OOP/31", "completion": "class RDL:\n    def __init__(self, envelopes):\n        self.envelopes = envelopes\n\n    def private_Russian_dolls(self):\n        # Sort envelopes: first by width, then by height in descending order\n        self.envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Extract heights for the longest increasing subsequence\n        heights = [h for _, h in self.envelopes]\n        \n        # Function to find the length of LIS using dynamic programming\n        def length_of_lis(nums):\n            from bisect import bisect_left\n            dp = []\n            for num in nums:\n                pos = bisect_left(dp, num)\n                if pos == len(dp):\n                    dp.append(num)\n                else:\n                    dp[pos] = num\n            return len(dp)\n        \n        return length_of_lis(heights)\n\n    def public_Russian_dolls(self):\n        return self.private_Russian_dolls()"}
{"task_id": "OOP/32", "completion": "class NDE:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Numbers_different(self):\n        if self.n == 0:\n            return 1\n        count = 9  # First digit can be 1-9\n        available_digits = 9  # Remaining digits can be 0 and other digits\n        for i in range(1, self.n):\n            count *= available_digits\n            available_digits -= 1\n        return count + 1  # Include 0\n\n    def public_Numbers_different(self):\n        return self.private_Numbers_different()"}
{"task_id": "OOP/33", "completion": "class MVL:\n    def __init__(self, matrix, k):\n        self.matrix = matrix\n        self.k = k\n\n    def __private_Maximum_value(self):\n        from itertools import combinations\n        \n        max_sum = float('-inf')\n        rows, cols = len(self.matrix), len(self.matrix[0]) if self.matrix else 0\n        \n        # Check all possible rectangular areas\n        for row1 in range(rows):\n            for row2 in range(row1, rows):\n                for col1 in range(cols):\n                    for col2 in range(col1, cols):\n                        current_sum = sum(self.matrix[i][j] for i in range(row1, row2 + 1) for j in range(col1, col2 + 1))\n                        if current_sum <= self.k:\n                            max_sum = max(max_sum, current_sum)\n\n        return max_sum if max_sum != float('-inf') else 0\n\n    def public_Maximum_value(self):\n        return self.__private_Maximum_value()"}
{"task_id": "OOP/34", "completion": "class DSS:\n    def __init__(self, nums):\n        self.nums = sorted(nums)\n\n    def __private_Divisible_subset(self):\n        n = len(self.nums)\n        if n == 0:\n            return []\n        \n        dp = [1] * n\n        prev = [-1] * n\n        \n        max_index = 0\n        \n        for i in range(n):\n            for j in range(i):\n                if self.nums[i] % self.nums[j] == 0 and dp[i] < dp[j] + 1:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n            if dp[i] > dp[max_index]:\n                max_index = i\n        \n        answer = []\n        while max_index != -1:\n            answer.append(self.nums[max_index])\n            max_index = prev[max_index]\n        \n        return answer[::-1]\n\n    def public_Divisible_subset(self):\n        return self.__private_Divisible_subset()"}
{"task_id": "OOP/35", "completion": "class PIT:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def private_positive_integer(self):\n        mod = 1337\n        \n        def mod_pow(a, b, mod):\n            result = 1\n            a = a % mod\n            while b > 0:\n                if b % 2 == 1:  # If b is odd\n                    result = (result * a) % mod\n                b //= 2\n                a = (a * a) % mod\n            return result\n        \n        # Convert b from array to a single integer\n        power = 0\n        for digit in self.b:\n            power = (power * 10 + digit) % (mod - 1)  # Fermat's little theorem adjustment\n        \n        return mod_pow(self.a, power, mod)\n\n    def public_positive_integer(self):\n        return self.private_positive_integer()"}
{"task_id": "OOP/36", "completion": "class DAG:\n    def __init__(self, nums1, nums2, k):\n        self.nums1 = nums1\n        self.nums2 = nums2\n        self.k = k\n\n    def private_decreasing_arrangement(self):\n        import heapq\n        min_heap = []\n        result = []\n        \n        for i in range(min(self.k, len(self.nums1))):\n            heapq.heappush(min_heap, (self.nums1[i] + self.nums2[0], i, 0))\n        \n        while min_heap and len(result) < self.k:\n            sum_value, i, j = heapq.heappop(min_heap)\n            result.append((self.nums1[i], self.nums2[j]))\n            \n            if j + 1 < len(self.nums2):\n                heapq.heappush(min_heap, (self.nums1[i] + self.nums2[j + 1], i, j + 1))\n\n        return result\n\n    def public_decreasing_arrangement(self):\n        return self.private_decreasing_arrangement()"}
{"task_id": "OOP/37", "completion": "class NBGG:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Guessing_Game(self, start, end, memo):\n        if start >= end:\n            return 0\n        if (start, end) in memo:\n            return memo[(start, end)]\n        \n        minimum_cost = float('inf')\n        for x in range(start, end):\n            cost = x + max(self.private_Guessing_Game(start, x, memo), self.private_Guessing_Game(x + 1, end, memo))\n            minimum_cost = min(minimum_cost, cost)\n        \n        memo[(start, end)] = minimum_cost\n        return minimum_cost\n\n    def public_Guessing_Game(self):\n        return self.private_Guessing_Game(1, self.n + 1, {})"}
{"task_id": "OOP/38", "completion": "class LSS:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Longest_subsequence(self):\n        if not self.nums:\n            return 0\n\n        up = down = 1\n        for i in range(1, len(self.nums)):\n            if self.nums[i] > self.nums[i - 1]:\n                up = down + 1\n            elif self.nums[i] < self.nums[i - 1]:\n                down = up + 1\n\n        return max(up, down)\n\n    def public_Longest_subsequence(self):\n        return self.__private_Longest_subsequence()"}
{"task_id": "OOP/39", "completion": "class EAC:\n    def __init__(self, nums, target):\n        self.nums = nums\n        self.target = target\n\n    def private_element_association(self):\n        def backtrack(start, target):\n            if target == 0:\n                return 1\n            if target < 0:\n                return 0\n            count = 0\n            for i in range(start, len(self.nums)):\n                count += backtrack(i + 1, target - self.nums[i])\n            return count\n        \n        return backtrack(0, self.target)\n\n    def public_element_association(self):\n        return self.private_element_association()"}
{"task_id": "OOP/40", "completion": "class SAS:\n    def __init__(self, matrix, k):\n        self.matrix = matrix\n        self.k = k\n\n    def private_Sort_ascending(self):\n        flattened = [element for row in self.matrix for element in row]\n        flattened.sort()\n        return flattened[self.k - 1]\n\n    def public_Sort_ascending(self):\n        return self.private_Sort_ascending()"}
{"task_id": "OOP/41", "completion": "class INT:\n    def __init__(self, s):\n        self.s = s\n\n    def private_Integer_nesting(self):\n        stack = []\n        current_number = ''\n        current_list = []\n\n        for char in self.s:\n            if char == '[':\n                # Start a new list, push the current list onto the stack\n                stack.append(current_list)\n                current_list = []\n            elif char == ']':\n                # End of the current list\n                if current_number:\n                    current_list.append(int(current_number))\n                    current_number = ''\n                if stack:\n                    last_list = stack.pop()\n                    last_list.append(current_list)\n                    current_list = last_list\n            elif char.isdigit() or char == '-':\n                # Collecting digits for the current number\n                current_number += char\n            elif char == ',':\n                # End of the number\n                if current_number:\n                    current_list.append(int(current_number))\n                    current_number = ''\n\n        # Final check for any remaining number\n        if current_number:\n            current_list.append(int(current_number))\n\n        return current_list[0] if current_list else None\n\n    def public_Integer_nesting(self):\n        return self.private_Integer_nesting()"}
{"task_id": "OOP/42", "completion": "class DOD:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Dictionary_order(self):\n        return sorted(range(1, self.n + 1), key=str)\n\n    def public_Dictionary_order(self):\n        return self.private_Dictionary_order()"}
{"task_id": "OOP/43", "completion": "class RAI:\n    def __init__(self, s, t):\n        self.s = s\n        self.t = t\n    \n    def private_Random_addition(self):\n        from collections import Counter\n        \n        count_s = Counter(self.s)\n        count_t = Counter(self.t)\n        \n        for char in count_t:\n            if count_t[char] != count_s.get(char, 0):\n                return char\n    \n    def public_Random_addition(self):\n        return self.private_Random_addition()"}
{"task_id": "OOP/44", "completion": "class RNE:\n    def __init__(self, n):\n        self.n = n\n\n    def private_remaining_numbers(self):\n        arr = list(range(1, self.n + 1))\n        left_to_right = True\n        \n        while len(arr) > 1:\n            if left_to_right:\n                arr.pop(0)  # Delete the first number\n                arr = [arr[i] for i in range(len(arr)) if i % 2 == 0]  # Delete every other number\n            else:\n                arr.pop()  # Delete the last number\n                arr = [arr[i] for i in range(len(arr)) if (len(arr) - i - 1) % 2 == 0]  # Delete every other number\n            left_to_right = not left_to_right\n            \n        return arr[0]\n\n    def public_remaining_numbers(self):\n        return self.private_remaining_numbers()"}
{"task_id": "OOP/45", "completion": "class PCN:\n    def __init__(self, rectangles):\n        self.rectangles = rectangles\n\n    def private_Parallel_coordinate(self):\n        if not self.rectangles:\n            return False\n\n        # Calculate the area and the corners\n        total_area = 0\n        corners = {}\n\n        for rect in self.rectangles:\n            x1, y1, x2, y2 = rect\n            area = (x2 - x1) * (y2 - y1)\n            total_area += area\n            \n            # Track corners\n            corners[(x1, y1)] = corners.get((x1, y1), 0) + 1\n            corners[(x1, y2)] = corners.get((x1, y2), 0) + 1\n            corners[(x2, y1)] = corners.get((x2, y1), 0) + 1\n            corners[(x2, y2)] = corners.get((x2, y2), 0) + 1\n\n        # Check if the total area is equal to the area of the bounding rectangle\n        x_min = min(x for x, y in corners.keys())\n        y_min = min(y for x, y in corners.keys())\n        x_max = max(x for x, y in corners.keys())\n        y_max = max(y for x, y in corners.keys())\n        bounding_area = (x_max - x_min) * (y_max - y_min)\n\n        if total_area != bounding_area:\n            return False\n\n        # Check that we have exactly 4 corners with count 1\n        corner_count = {c: count for c, count in corners.items() if count % 2 == 1}\n        \n        return len(corner_count) == 4 and all(count == 1 for count in corner_count.values())\n\n    def public_Parallel_coordinate(self):\n        return self.private_Parallel_coordinate()"}
{"task_id": "OOP/46", "completion": "class VED:\n    def __init__(self, data):\n        self.data = data\n\n    def private_Valid_encoding(self):\n        n = len(self.data)\n        i = 0\n\n        while i < n:\n            if self.data[i] >> 7 == 0:  # 1-byte character\n                i += 1\n            elif self.data[i] >> 5 == 0b110:  # 2-byte character\n                if i + 1 >= n or self.data[i + 1] >> 6 != 0b10:\n                    return False\n                i += 2\n            elif self.data[i] >> 4 == 0b1110:  # 3-byte character\n                if i + 2 >= n or self.data[i + 1] >> 6 != 0b10 or self.data[i + 2] >> 6 != 0b10:\n                    return False\n                i += 3\n            elif self.data[i] >> 3 == 0b11110:  # 4-byte character\n                if i + 3 >= n or self.data[i + 1] >> 6 != 0b10 or self.data[i + 2] >> 6 != 0b10 or self.data[i + 3] >> 6 != 0b10:\n                    return False\n                i += 4\n            else:\n                return False\n\n        return True\n\n    def public_Valid_encoding(self):\n        return self.private_Valid_encoding()"}
{"task_id": "OOP/47", "completion": "class LST:\n    def __init__(self, s, k):\n        self.s = s\n        self.k = k\n\n    def private_Longest_substring(self):\n        max_length = 0\n        n = len(self.s)\n\n        for start in range(n):\n            char_count = {}\n            unique_char_count = 0\n            for end in range(start, n):\n                char = self.s[end]\n                if char not in char_count:\n                    char_count[char] = 0\n                    unique_char_count += 1\n                char_count[char] += 1\n\n                while unique_char_count > len(char_count):\n                    left_char = self.s[start]\n                    char_count[left_char] -= 1\n                    if char_count[left_char] == 0:\n                        del char_count[left_char]\n                        unique_char_count -= 1\n                    start += 1\n\n                if all(count >= self.k for count in char_count.values()):\n                    max_length = max(max_length, end - start + 1)\n\n        return max_length\n\n    def public_Longest_substring(self):\n        return self.private_Longest_substring()"}
{"task_id": "OOP/48", "completion": "class CRT:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_clockwise_rotation(self, k):\n        n = len(self.nums)\n        arrk = self.nums[-k:] + self.nums[:-k]\n        return sum(i * arrk[i] for i in range(n))\n\n    def public_clockwise_rotation(self):\n        max_value = float('-inf')\n        n = len(self.nums)\n        for k in range(n):\n            current_value = self.private_clockwise_rotation(k)\n            max_value = max(max_value, current_value)\n        return max_value"}
{"task_id": "OOP/49", "completion": "class MRC:\n    def __init__(self, n):\n        self.n = n\n\n    def __private_Minimum_replacements(self, n):\n        if n == 1:\n            return 0\n        if n % 2 == 0:\n            return 1 + self.__private_Minimum_replacements(n // 2)\n        else:\n            return 1 + min(self.__private_Minimum_replacements(n + 1), self.__private_Minimum_replacements(n - 1))\n\n    def public_Minimum_replacements(self):\n        return self.__private_Minimum_replacements(self.n)"}
{"task_id": "OOP/50", "completion": "class IIG:\n    def __init__(self, n):\n        self.n = n\n\n    def __private_Infinite_integers(self):\n        return self.n\n\n    def public_Infinite_integers(self):\n        return self.__private_Infinite_integers()"}
{"task_id": "OOP/51", "completion": "class SNU:\n    def __init__(self, num: str, k: int):\n        self.num = num\n        self.k = k\n\n    def private_smallest_number(self) -> str:\n        stack = []\n        remaining_digits = len(self.num) - self.k\n        \n        for digit in self.num:\n            while self.k > 0 and stack and stack[-1] > digit:\n                stack.pop()\n                self.k -= 1\n            stack.append(digit)\n        \n        # If there are still digits to remove\n        while self.k > 0:\n            stack.pop()\n            self.k -= 1\n        \n        # Join the remaining digits and remove leading zeros\n        smallest_number = ''.join(stack)[:remaining_digits].lstrip('0')\n        \n        return smallest_number if smallest_number else '0'\n\n    def public_smallest_number(self) -> str:\n        return self.private_smallest_number()"}
{"task_id": "OOP/52", "completion": "class RQU:\n    def __init__(self, people):\n        self.people = people\n\n    def private_Rank_queue(self):\n        result = []\n        for h, k in sorted(self.people, key=lambda x: (-x[0], x[1])):\n            result.insert(k, [h, k])\n        return result\n\n    def public_Rank_queue(self):\n        return self.private_Rank_queue()"}
{"task_id": "OOP/53", "completion": "class CSR:\n    def __init__(self, nums, m):\n        self.nums = nums\n        self.m = m\n\n    def private_Continuous_subarray(self):\n        def can_partition(max_sum):\n            count, current_sum = 1, 0\n            for num in self.nums:\n                current_sum += num\n                if current_sum > max_sum:\n                    count += 1\n                    current_sum = num\n                    if count > self.m:\n                        return False\n            return True\n\n        left, right = max(self.nums), sum(self.nums)\n        while left < right:\n            mid = (left + right) // 2\n            if can_partition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    def public_Continuous_subarray(self):\n        return self.private_Continuous_subarray()"}
{"task_id": "OOP/54", "completion": "class EAY:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Equidistant_array(self):\n        count = 0\n        n = len(self.nums)\n\n        for i in range(n):\n            for j in range(i + 2, n + 1):\n                if self.is_arithmetic(self.nums[i:j]):\n                    count += 1\n\n        return count\n\n    def public_Equidistant_array(self):\n        return self.private_Equidistant_array()\n    \n    def is_arithmetic(self, array):\n        if len(array) < 2:\n            return False\n        diff = array[1] - array[0]\n        for i in range(2, len(array)):\n            if array[i] - array[i - 1] != diff:\n                return False\n        return True"}
{"task_id": "OOP/55", "completion": "class SSB:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_split_subset(self):\n        total_sum = sum(self.nums)\n        if total_sum % 2 != 0:\n            return False\n        \n        target = total_sum // 2\n        n = len(self.nums)\n        dp = [False] * (target + 1)\n        dp[0] = True\n        \n        for num in self.nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n\n        return dp[target]\n\n    def public_split_subset(self):\n        return self.__private_split_subset()"}
{"task_id": "OOP/56", "completion": "class PBI:\n    def __init__(self, board):\n        self.board = board\n\n    def private_Placed_battleships(self):\n        if not self.board:\n            return 0\n\n        count = 0\n        for i in range(len(self.board)):\n            for j in range(len(self.board[0])):\n                if self.board[i][j] == 'X':\n                    # If it's the first cell of a battleship\n                    if (i == 0 or self.board[i - 1][j] == '.') and (j == 0 or self.board[i][j - 1] == '.'):\n                        count += 1\n        return count\n\n    def public_Placed_battleships(self):\n        return self.private_Placed_battleships()"}
{"task_id": "OOP/57", "completion": "class MRU:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Maximum_result(self):\n        max_result = float('-inf')\n        n = len(self.nums)\n        for i in range(n):\n            for j in range(i, n):\n                max_result = max(max_result, self.nums[i] ^ self.nums[j])\n        return max_result\n\n    def public_Maximum_result(self):\n        return self.__private_Maximum_result()"}
{"task_id": "OOP/58", "completion": "class DOR:\n    def __init__(self, s):\n        self.s = s\n\n    def private_Disordered_order(self):\n        number_words = {\n            \"zero\": 0,\n            \"one\": 1,\n            \"two\": 2,\n            \"three\": 3,\n            \"four\": 4,\n            \"five\": 5,\n            \"six\": 6,\n            \"seven\": 7,\n            \"eight\": 8,\n            \"nine\": 9\n        }\n\n        words = self.s.split()\n        numbers = []\n\n        for word in words:\n            if word in number_words:\n                numbers.append(number_words[word])\n        \n        return sorted(numbers)\n\n    def public_Disordered_order(self):\n        return self.private_Disordered_order()"}
{"task_id": "OOP/59", "completion": "class LSR:\n    def __init__(self, s: str, k: int):\n        self.s = s\n        self.k = k\n\n    def private_Longest_substring(self) -> int:\n        max_length = 0\n        left = 0\n        count = {}\n\n        for right in range(len(self.s)):\n            count[self.s[right]] = count.get(self.s[right], 0) + 1\n            \n            while (right - left + 1) - max(count.values()) > self.k:\n                count[self.s[left]] -= 1\n                if count[self.s[left]] == 0:\n                    del count[self.s[left]]\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n\n    def public_Longest_substring(self) -> int:\n        return self.private_Longest_substring()"}
{"task_id": "OOP/60", "completion": "class GS:\n    def __init__(self, start, end, bank):\n        self.start = start\n        self.end = end\n        self.bank = set(bank)\n\n    def private_gene_sequence(self):\n        if self.end not in self.bank:\n            return -1\n        \n        from collections import deque\n        \n        queue = deque([(self.start, 0)])\n        visited = set([self.start])\n        \n        while queue:\n            current, changes = queue.popleft()\n            if current == self.end:\n                return changes\n            \n            for i in range(len(current)):\n                for nucleotide in 'ACGT':\n                    if nucleotide != current[i]:\n                        next_sequence = current[:i] + nucleotide + current[i+1:]\n                        if next_sequence in self.bank and next_sequence not in visited:\n                            visited.add(next_sequence)\n                            queue.append((next_sequence, changes + 1))\n        \n        return -1\n\n    def public_gene_sequence(self):\n        return self.private_gene_sequence()"}
{"task_id": "OOP/61", "completion": "class SIL:\n    def __init__(self):\n        self.intervals = []\n\n    def __private_Set_intervals(self):\n        if not self.intervals:\n            return 0\n        \n        self.intervals.sort(key=lambda x: x[1])\n        count = 0\n        end = float('-inf')\n        \n        for interval in self.intervals:\n            if interval[0] < end:\n                count += 1\n            else:\n                end = interval[1]\n        \n        return count\n\n    def public_Set_intervals(self, intervals):\n        self.intervals = intervals\n        return self.__private_Set_intervals()"}
{"task_id": "OOP/62", "completion": "class RSC:\n    def __init__(self, intervals):\n        self.intervals = intervals\n\n    def __private_Right_section(self):\n        n = len(self.intervals)\n        result = [-1] * n\n        for i in range(n):\n            start_i, end_i = self.intervals[i]\n            min_index = -1\n            for j in range(n):\n                if self.intervals[j][0] >= end_i:\n                    if min_index == -1 or self.intervals[j][0] < self.intervals[min_index][0]:\n                        min_index = j\n            result[i] = min_index\n        return result\n\n    def public_Right_section(self):\n        return self.__private_Right_section()"}
{"task_id": "OOP/63", "completion": "class SIN:\n    def __init__(self, s, p):\n        self.s = s\n        self.p = p\n\n    def __private_start_index(self):\n        from collections import Counter\n\n        p_length = len(self.p)\n        s_length = len(self.s)\n        if p_length > s_length:\n            return []\n\n        p_counter = Counter(self.p)\n        s_counter = Counter(self.s[:p_length])\n        result = []\n\n        if s_counter == p_counter:\n            result.append(0)\n\n        for i in range(1, s_length - p_length + 1):\n            # update the counter for the current window\n            s_counter[self.s[i - 1]] -= 1\n            if s_counter[self.s[i - 1]] == 0:\n                del s_counter[self.s[i - 1]]\n\n            s_counter[self.s[i + p_length - 1]] += 1\n\n            if s_counter == p_counter:\n                result.append(i)\n\n        return result\n\n    def public_start_index(self):\n        return self.__private_start_index()"}
{"task_id": "OOP/64", "completion": "class DOE:\n    def __init__(self, n, k):\n        self.n = n\n        self.k = k\n\n    def private_Dictionary_order(self):\n        def count_less_equal(x):\n            count = 0\n            for i in range(1, self.n + 1):\n                count += min(x // i, self.n)\n            return count\n\n        left, right = 1, self.n\n        while left < right:\n            mid = (left + right) // 2\n            if count_less_equal(mid) < self.k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    def public_Dictionary_order(self):\n        return self.private_Dictionary_order()"}
{"task_id": "OOP/65", "completion": "class CLA:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Complete_ladder(self):\n        rows = 0\n        coins_used = 0\n        while coins_used + (rows + 1) <= self.n:\n            rows += 1\n            coins_used += rows\n        return rows\n\n    def public_Complete_ladder(self):\n        return self.private_Complete_ladder()"}
{"task_id": "OOP/66", "completion": "class AFO:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Array_form(self):\n        seen = set()\n        duplicates = set()\n        for num in self.nums:\n            if num in seen:\n                duplicates.add(num)\n            else:\n                seen.add(num)\n        return list(duplicates)\n\n    def public_Array_form(self):\n        return self.__private_Array_form()"}
{"task_id": "OOP/67", "completion": "class ISAR:\n    def __init__(self, chars):\n        self.chars = chars\n\n    def __private_Input_sarray(self):\n        if not self.chars:\n            return 0\n        \n        write_index = 0\n        count = 1\n\n        for i in range(1, len(self.chars)):\n            if self.chars[i] == self.chars[i - 1]:\n                count += 1\n            else:\n                self.chars[write_index] = self.chars[i - 1]\n                write_index += 1\n                if count > 1:\n                    for digit in str(count):\n                        self.chars[write_index] = digit\n                        write_index += 1\n                count = 1\n\n        # handle the last group\n        self.chars[write_index] = self.chars[-1]\n        write_index += 1\n        if count > 1:\n            for digit in str(count):\n                self.chars[write_index] = digit\n                write_index += 1\n\n        return write_index\n\n    def public_Input_sarray(self):\n        return self.__private_Input_sarray()"}
{"task_id": "OOP/68", "completion": "class ESQ:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Equidistant_subsequence(self):\n        count = 0\n        n = len(self.nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = self.nums[j] - self.nums[i]\n                next_index = j + diff\n                while next_index < n:\n                    if self.nums[next_index] - self.nums[j] == diff:\n                        count += 1\n                    next_index += diff\n        return count\n\n    def public_Equidistant_subsequence(self):\n        return self.__private_Equidistant_subsequence()"}
{"task_id": "OOP/69", "completion": "class EDA:\n    def __init__(self, points):\n        self.points = points\n\n    def __private_Euclidean_distance(self, p1, p2):\n        return (p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2\n\n    def public_Euclidean_distance(self):\n        count = 0\n        distance_count = {}\n        \n        for point in self.points:\n            distance_count.clear()\n            for other in self.points:\n                if point != other:\n                    dist = self.__private_Euclidean_distance(point, other)\n                    distance_count[dist] = distance_count.get(dist, 0) + 1\n            \n            for dist in distance_count:\n                count += distance_count[dist] * (distance_count[dist] - 1)\n        \n        return count"}
{"task_id": "OOP/70", "completion": "class DODE:\n    def __init__(self, s):\n        self.s = s\n\n    def private_descending_order(self):\n        from collections import Counter\n        frequency = Counter(self.s)\n        sorted_characters = sorted(frequency.items(), key=lambda x: x[1], reverse=True)\n        result = ''.join([char * count for char, count in sorted_characters])\n        return result\n\n    def public_descending_order(self):\n        return self.private_descending_order()"}
{"task_id": "OOP/71", "completion": "class EEL:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Element_equality(self):\n        min_num = min(self.nums)\n        operations = sum(num - min_num for num in self.nums)\n        return operations\n\n    def public_Element_equality(self):\n        return self.__private_Element_equality()"}
{"task_id": "OOP/72", "completion": "class AST:\n    def __init__(self, nums1, nums2, nums3, nums4):\n        self.nums1 = nums1\n        self.nums2 = nums2\n        self.nums3 = nums3\n        self.nums4 = nums4\n\n    def private_Array_stlength(self):\n        from collections import Counter\n        \n        count_ab = Counter(a + b for a in self.nums1 for b in self.nums2)\n        count_cd = Counter(c + d for c in self.nums3 for d in self.nums4)\n        \n        result = 0\n        for sum_ab, frequency in count_ab.items():\n            result += frequency * count_cd.get(-sum_ab, 0)\n        \n        return result\n\n    def public_Array_stlength(self):\n        return self.private_Array_stlength()"}
{"task_id": "OOP/73", "completion": "class SPAR:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Subsequences_patterns(self):\n        n = len(self.nums)\n        if n < 3:\n            return False\n        \n        third = float('-inf')\n        stack = []\n        \n        for i in range(n - 1, -1, -1):\n            if self.nums[i] < third:\n                return True\n            while stack and self.nums[i] > stack[-1]:\n                third = stack.pop()\n            stack.append(self.nums[i])\n        \n        return False\n\n    def public_Subsequences_patterns(self):\n        return self.private_Subsequences_patterns()"}
{"task_id": "OOP/74", "completion": "class SPR:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Suences_patterns(self, index, visited):\n        slow = index\n        fast = index\n        while True:\n            slow = (slow + self.nums[slow]) % len(self.nums)\n            fast = (fast + self.nums[fast]) % len(self.nums)\n            fast = (fast + self.nums[fast]) % len(self.nums)\n            if slow == fast:\n                break\n        if slow == index:\n            circular = True\n            direction = self.nums[index] > 0\n            while visited[slow] == 0:\n                visited[slow] = 1\n                if (self.nums[slow] > 0) != direction:\n                    circular = False\n                slow = (slow + self.nums[slow]) % len(self.nums)\n            return circular and all(v == 1 for v in visited)\n        return False\n\n    def public_Suences_patterns(self):\n        visited = [0] * len(self.nums)\n        for i in range(len(self.nums)):\n            if visited[i] == 0:\n                if self.private_Suences_patterns(i, visited):\n                    return True\n        return False"}
{"task_id": "OOP/75", "completion": "class ArrayEqualizer:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_One_operation(self):\n        target = round(sum(self.nums) / len(self.nums))\n        return sum(abs(num - target) for num in self.nums)\n\n    def public_One_operation(self):\n        return self.__private_One_operation()"}
{"task_id": "OOP/76", "completion": "class PIGE:\n    def __init__(self, maxChoosableInteger, desiredTotal):\n        self.maxChoosableInteger = maxChoosableInteger\n        self.desiredTotal = desiredTotal\n        self.memo = {}\n\n    def private_Public_integer(self, chosen, total):\n        if total >= 100:\n            return False\n        if (chosen, total) in self.memo:\n            return self.memo[(chosen, total)]\n        \n        for i in range(1, self.maxChoosableInteger + 1):\n            if not (chosen & (1 << i)):\n                if total + i >= 100 or not self.private_Public_integer(chosen | (1 << i), total + i):\n                    self.memo[(chosen, total)] = True\n                    return True\n        \n        self.memo[(chosen, total)] = False\n        return False\n\n    def public_Public_integer(self):\n        return self.private_Public_integer(0, self.desiredTotal)"}
{"task_id": "OOP/77", "completion": "class IIFI:\n    def __init__(self, s1, n1, s2, n2):\n        self.s1 = s1\n        self.n1 = n1\n        self.s2 = s2\n        self.n2 = n2\n\n    def private_Italic_tion(self):\n        from collections import Counter\n        \n        count_s1 = Counter(self.s1)\n        count_s2 = Counter(self.s2)\n        \n        max_m = float('inf')\n        for char in count_s1:\n            if char in count_s2:\n                max_m = min(max_m, count_s2[char] // count_s1[char])\n            else:\n                return 0\n        return max_m * self.n2 // self.n1\n\n    def public_Italic_tion(self):\n        return self.private_Italic_tion()"}
{"task_id": "OOP/78", "completion": "class IZOE:\n    def __init__(self, s):\n        self.s = s\n\n    def private_Infinity_Zone(self):\n        base = \"abcdefghijklmnopqrstuvwxyz\"\n        substrings = set()\n        n = len(self.s)\n        \n        # Generate substrings from the given string and add to the set\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                substr = self.s[i:j]\n                if all(c in base for c in substr):\n                    substrings.add(substr)\n        \n        # Calculate different non-empty substrings in the infinite base\n        result = len(substrings)\n        return result\n\n    def public_Infinity_Zone(self):\n        return self.private_Infinity_Zone()"}
{"task_id": "OOP/79", "completion": "class EDC:\n    def __init__(self, words):\n        self.words = words\n\n    def private_Excluding_Duplicates(self):\n        unique_words = list(set(self.words))\n        conjunctions = [word for word in unique_words if word in {'and', 'or', 'but', 'nor', 'for', 'yet', 'so'}]\n        return conjunctions\n\n    def public_Excluding_Duplicates(self):\n        return self.private_Excluding_Duplicates()"}
{"task_id": "OOP/80", "completion": "class EMSP:\n    def __init__(self, matchsticks):\n        self.matchsticks = matchsticks\n\n    def private_Each_matchstick(self, side_length, sides, index):\n        if index == len(self.matchsticks):\n            return sides[0] == sides[1] == sides[2] == sides[3] == side_length\n        \n        for i in range(4):\n            if sides[i] + self.matchsticks[index] <= side_length:\n                sides[i] += self.matchsticks[index]\n                if self.private_Each_matchstick(side_length, sides, index + 1):\n                    return True\n                sides[i] -= self.matchsticks[index]\n\n        return False\n\n    def public_Each_matchstick(self):\n        total_length = sum(self.matchsticks)\n        if total_length % 4 != 0:\n            return False\n        \n        side_length = total_length // 4\n        sides = [0] * 4\n        \n        return self.private_Each_matchstick(side_length, sides, 0)"}
{"task_id": "OOP/81", "completion": "class MSBS:\n    def __init__(self, strs, m, n):\n        self.strs = strs\n        self.m = m\n        self.n = n\n\n    def private_Maximum_subset(self, index, m, n):\n        if index == len(self.strs):\n            return 0\n        zeros = self.strs[index].count('0')\n        ones = self.strs[index].count('1')\n        \n        # Not including the current string\n        not_included = self.private_Maximum_subset(index + 1, m, n)\n        \n        # Including the current string (if possible)\n        included = 0\n        if m >= zeros and n >= ones:\n            included = 1 + self.private_Maximum_subset(index + 1, m - zeros, n - ones)\n        \n        return max(included, not_included)\n\n    def public_Maximum_subset(self):\n        return self.private_Maximum_subset(0, self.m, self.n)"}
{"task_id": "OOP/82", "completion": "class ANUB:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Any_numbers(self):\n        total_hamming_distance = 0\n        n = len(self.nums)\n        for i in range(32):  # Assuming 32-bit integers\n            count_one = sum((num >> i) & 1 for num in self.nums)\n            total_hamming_distance += count_one * (n - count_one)\n        return total_hamming_distance\n\n    def public_Any_numbers(self):\n        return self.private_Any_numbers()"}
{"task_id": "OOP/83", "completion": "class MPRD:\n    def __init__(self, n):\n        self.n = n\n\n    def __private_Maximum_palindrome(self):\n        upper_limit = 10**self.n - 1\n        lower_limit = 10**(self.n - 1)\n        max_palindrome = 0\n\n        for i in range(upper_limit, lower_limit - 1, -1):\n            for j in range(i, lower_limit - 1, -1):\n                product = i * j\n                if self.is_palindrome(product) and product > max_palindrome:\n                    max_palindrome = product\n\n        return max_palindrome\n\n    def public_Maximum_palindrome(self):\n        return self.__private_Maximum_palindrome()\n\n    def is_palindrome(self, number):\n        return str(number) == str(number)[::-1]"}
{"task_id": "OOP/84", "completion": "class MSRI:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Magic_String(self):\n        if self.n == 0:\n            return 0\n        s = [1, 2]  # Starting sequence\n        idx = 2  # Index to determine how many times to add 1 or 2\n        while len(s) < self.n:\n            count = s[idx]  # Number of times to repeat\n            next_num = 2 if s[-1] == 1 else 1  # Alternate between 1 and 2\n            s.extend([next_num] * count)  # Add the next number count times\n            idx += 1\n        return s[:self.n].count(1)  # Count 1s in the first n elements\n\n    def public_Magic_String(self):\n        return self.private_Magic_String()  # Call the private function and return its result"}
{"task_id": "OOP/85", "completion": "class MBS:\n    def __init__(self, n):\n        self.n = n\n\n    def __private_Minimum_base(self):\n        x = self.n\n        for m in range(62, 1, -1):\n            k = int(x ** (1 / m))\n            if (k ** m - 1) // (k - 1) == x:\n                return str(k)\n            if (k + 1) ** m - 1 == x * k:\n                return str(k + 1)\n        return str(x - 1)\n\n    def public_Minimum_base(self):\n        return self.__private_Minimum_base()"}
{"task_id": "OOP/86", "completion": "class ISQE:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_increasing_subsequence(self):\n        def find_subsequences(start, path):\n            if len(path) > 1:\n                result.add(tuple(path))\n            for i in range(start, len(self.nums)):\n                if not path or self.nums[i] >= path[-1]:\n                    find_subsequences(i + 1, path + [self.nums[i]])\n\n        result = set()\n        find_subsequences(0, [])\n        return list(result)\n\n    def public_increasing_subsequence(self):\n        return self.private_increasing_subsequence()"}
{"task_id": "OOP/87", "completion": "class IFIP:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Important_flipping(self, left, right):\n        if left >= right:\n            return 0\n        \n        mid = (left + right) // 2\n        count = self.private_Important_flipping(left, mid) + self.private_Important_flipping(mid + 1, right)\n        \n        j = mid + 1\n        for i in range(left, mid + 1):\n            while j <= right and self.nums[i] > 2 * self.nums[j]:\n                j += 1\n            count += j - (mid + 1)\n        \n        self.nums[left:right + 1] = sorted(self.nums[left:right + 1])\n        return count\n\n    def public_Important_flipping(self):\n        return self.private_Important_flipping(0, len(self.nums) - 1)"}
{"task_id": "OOP/88", "completion": "class DESI:\n    def __init__(self, nums, target):\n        self.nums = nums\n        self.target = target\n\n    def private_Different_expressions(self, index=0, current_sum=0):\n        if index == len(self.nums):\n            return 1 if current_sum == self.target else 0\n        \n        # choose the current number with a plus sign\n        add = self.private_Different_expressions(index + 1, current_sum + self.nums[index])\n        # choose the current number with a minus sign\n        subtract = self.private_Different_expressions(index + 1, current_sum - self.nums[index])\n        \n        return add + subtract\n\n    def public_Different_expressions(self):\n        return self.private_Different_expressions()"}
{"task_id": "OOP/89", "completion": "class DTVL:\n    def __init__(self, mat):\n        self.mat = mat\n\n    def __private_Diagonal_traversal(self):\n        if not self.mat or not self.mat[0]:\n            return []\n\n        m, n = len(self.mat), len(self.mat[0])\n        result = []\n        \n        for d in range(m + n - 1):\n            if d < n:\n                row, col = 0, d\n            else:\n                row, col = d - n + 1, n - 1\n            \n            diagonal = []\n            while row < m and col >= 0:\n                diagonal.append(self.mat[row][col])\n                row += 1\n                col -= 1\n            \n            if d % 2 == 0:\n                result.extend(diagonal[::-1])\n            else:\n                result.extend(diagonal)\n\n        return result\n\n    def public_Diagonal_traversal(self):\n        return self.__private_Diagonal_traversal()"}
{"task_id": "OOP/90", "completion": "class ATSA:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Array_traversal(self):\n        n = len(self.nums)\n        result = [-1] * n\n        stack = []\n\n        for i in range(2 * n):\n            current_index = i % n\n            while stack and self.nums[stack[-1]] < self.nums[current_index]:\n                index = stack.pop()\n                result[index] = self.nums[current_index]\n            if i < n:\n                stack.append(current_index)\n\n        return result\n\n    def public_Array_traversal(self):\n        return self.private_Array_traversal()"}
{"task_id": "OOP/91", "completion": "class RL:\n    def __init__(self, s):\n        self.s = s\n\n    def __private_Return_length(self):\n        n = len(self.s)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = 1\n\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if self.s[i] == self.s[j]:\n                    dp[i][j] = 2 + dp[i + 1][j - 1] if length > 2 else 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n        return dp[0][n - 1]\n\n    def public_Return_length(self):\n        return self.__private_Return_length()"}
{"task_id": "OOP/92", "completion": "class NCC:\n    def __init__(self, amount, coins):\n        self.amount = amount\n        self.coins = coins\n\n    def __coin_combinations(self, amount, coins):\n        if amount == 0:\n            return 1\n        if amount < 0 or not coins:\n            return 0\n        return self.__coin_combinations(amount - coins[0], coins) + self.__coin_combinations(amount, coins[1:])\n\n    def public_combinations(self):\n        return self.__coin_combinations(self.amount, self.coins)"}
{"task_id": "OOP/93", "completion": "class ML:\n    def __init__(self, strs):\n        self.strs = strs\n\n    def __private_Maximum_length(self):\n        max_length = -1\n        for s in self.strs:\n            if s.isalpha() and len(s) > max_length:\n                max_length = len(s)\n        return max_length if max_length > 0 else -1\n\n    def public_Maximum_length(self):\n        return self.__private_Maximum_length()"}
{"task_id": "OOP/94", "completion": "class LS:\n    def __init__(self, s, dictionary):\n        self.s = s\n        self.dictionary = dictionary\n\n    def __private_Longest_string(self):\n        longest_str = \"\"\n        for candidate in self.dictionary:\n            if self._is_subsequence(candidate):\n                if (len(candidate) > len(longest_str) or \n                    (len(candidate) == len(longest_str) and candidate < longest_str)):\n                    longest_str = candidate\n        return longest_str\n\n    def public_Longest_string(self):\n        return self.__private_Longest_string()\n\n    def _is_subsequence(self, candidate):\n        it = iter(self.s)\n        return all(char in it for char in candidate)"}
{"task_id": "OOP/95", "completion": "class AL:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Array_length(self):\n        count_map = {0: -1}\n        max_length = 0\n        count = 0\n\n        for index, number in enumerate(self.nums):\n            count += 1 if number == 1 else -1\n\n            if count in count_map:\n                max_length = max(max_length, index - count_map[count])\n            else:\n                count_map[count] = index\n\n        return max_length\n\n    def public_Array_length(self):\n        return self.__private_Array_length()"}
{"task_id": "OOP/96", "completion": "class CQ:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Construction_quantity(self):\n        def count(arr, pos):\n            if pos > len(arr):\n                return 1\n            total = 0\n            for i in range(pos, len(arr)):\n                arr[pos-1], arr[i] = arr[i], arr[pos-1]  # Swap\n                if arr[pos-1] % pos == 0 or pos % arr[pos-1] == 0:\n                    total += count(arr, pos + 1)\n                arr[pos-1], arr[i] = arr[i], arr[pos-1]  # Swap back\n            return total\n\n        initial_arr = list(range(1, self.n + 1))\n        return count(initial_arr, 1)\n\n    def public_Construction_quantity(self):\n        return self.private_Construction_quantity()"}
{"task_id": "OOP/97", "completion": "import random\n\nclass RS:\n    def __init__(self, w):\n        self.w = w\n\n    def __private_Return_Subscript(self):\n        total_weight = sum(self.w)\n        random_value = random.uniform(0, total_weight)\n        cumulative_weight = 0\n        for i, weight in enumerate(self.w):\n            cumulative_weight += weight\n            if random_value <= cumulative_weight:\n                return i\n        return len(self.w) - 1  # Should not reach here if weights are positive\n\n    def public_Return_Subscript(self):\n        return self.__private_Return_Subscript()"}
{"task_id": "OOP/98", "completion": "class MG:\n    def __init__(self, board):\n        self.board = board\n        self.click = None\n\n    def private_Minesweeping_game(self, x, y):\n        if self.board[x][y] == 'M':\n            self.board[x][y] = 'X'\n            return self.board\n        \n        def count_mines(x, y):\n            count = 0\n            for i in range(-1, 2):\n                for j in range(-1, 2):\n                    if 0 <= x + i < len(self.board) and 0 <= y + j < len(self.board[0]) and not (i == 0 and j == 0):\n                        count += self.board[x + i][y + j] == 'M'\n            return count\n        \n        mine_count = count_mines(x, y)\n        \n        if mine_count > 0:\n            self.board[x][y] = str(mine_count)\n        else:\n            self.board[x][y] = 'B'\n            for i in range(-1, 2):\n                for j in range(-1, 2):\n                    if 0 <= x + i < len(self.board) and 0 <= y + j < len(self.board[0]) and self.board[x + i][y + j] == 'E':\n                        self.private_Minesweeping_game(x + i, y + j)\n        \n        return self.board\n\n    def public_Minesweeping_game(self, click):\n        self.click = click\n        return self.private_Minesweeping_game(click[0], click[1])"}
{"task_id": "OOP/99", "completion": "class NP:\n    def __init__(self, nums, k):\n        self.nums = nums\n        self.k = k\n\n    def __private_Number_Pairs(self):\n        if self.k < 0:\n            return 0\n        num_set = set(self.nums)\n        pairs = set()\n        for num in num_set:\n            if self.k == 0:\n                if self.nums.count(num) > 1:\n                    pairs.add((num, num))\n            else:\n                if (num + self.k) in num_set:\n                    pairs.add((num, num + self.k))\n        return len(pairs)\n\n    def public_Number_Pairs(self):\n        return self.__private_Number_Pairs()"}
{"task_id": "OOP/100", "completion": "class SOP:\n    def __init__(self, num1, num2):\n        self.num1 = num1\n        self.num2 = num2\n\n    def __String_product(self):\n        real1, imag1 = self.num1\n        real2, imag2 = self.num2\n        real_part = real1 * real2 - imag1 * imag2\n        imag_part = real1 * imag2 + imag1 * real2\n        return f\"{real_part} + {imag_part}i\"\n\n    def public_String_product(self):\n        return self.__String_product()"}
{"task_id": "OOP/101", "completion": "class MTD:\n    def __init__(self, timePoints):\n        self.timePoints = timePoints\n\n    def __Minimum_difference(self):\n        times_in_minutes = []\n        for time in self.timePoints:\n            hours, minutes = map(int, time.split(':'))\n            times_in_minutes.append(hours * 60 + minutes)\n        \n        times_in_minutes.sort()\n        min_diff = float('inf')\n        \n        for i in range(1, len(times_in_minutes)):\n            min_diff = min(min_diff, times_in_minutes[i] - times_in_minutes[i - 1])\n        \n        # Check the difference between the last and first time (circular)\n        min_diff = min(min_diff, 1440 - (times_in_minutes[-1] - times_in_minutes[0]))\n        \n        return min_diff\n\n    def public_Minimum_difference(self):\n        return self.__Minimum_difference()"}
{"task_id": "OOP/102", "completion": "class NOO:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __Number_occurrences(self):\n        low, high = 0, len(self.nums) - 1\n        while low < high:\n            mid = low + (high - low) // 2\n            if mid % 2 == 1:\n                mid -= 1\n            if self.nums[mid] == self.nums[mid + 1]:\n                low = mid + 2\n            else:\n                high = mid\n        return self.nums[low]\n\n    def public_Number_occurrences(self):\n        return self.__Number_occurrences()"}
{"task_id": "OOP/103", "completion": "class MS:\n    def __init__(self, mat):\n        self.mat = mat\n\n    def private_Matrices_size(self):\n        rows = len(self.mat)\n        cols = len(self.mat[0]) if rows > 0 else 0\n        \n        # Initialize the result matrix with infinity\n        distance = [[float('inf')] * cols for _ in range(rows)]\n\n        # First pass: Check for 0s and calculate distances\n        for i in range(rows):\n            for j in range(cols):\n                if self.mat[i][j] == 0:\n                    distance[i][j] = 0\n                else:\n                    if i > 0:\n                        distance[i][j] = min(distance[i][j], distance[i - 1][j] + 1)\n                    if j > 0:\n                        distance[i][j] = min(distance[i][j], distance[i][j - 1] + 1)\n\n        # Second pass: Check in the opposite direction\n        for i in range(rows - 1, -1, -1):\n            for j in range(cols - 1, -1, -1):\n                if i < rows - 1:\n                    distance[i][j] = min(distance[i][j], distance[i + 1][j] + 1)\n                if j < cols - 1:\n                    distance[i][j] = min(distance[i][j], distance[i][j + 1] + 1)\n\n        return distance\n\n    def public_Matrices_size(self):\n        return self.private_Matrices_size()"}
{"task_id": "OOP/104", "completion": "class RB:\n    def __init__(self, boxes):\n        self.boxes = boxes\n\n    def private_Remove_Box(self, boxes):\n        if not boxes:\n            return 0\n        \n        max_points = 0\n        n = len(boxes)\n\n        # Create a dp table to store max points for subsequences\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(1, n + 1):  # Length of the current subsequence\n            for i in range(n - length + 1):\n                j = i + length - 1\n                # Count the number of same colored boxes at the end\n                k = j\n                while k >= i and boxes[k] == boxes[j]:\n                    k -= 1\n                count = j - k  # Number of boxes of the same color at the end\n                # Calculate the points if we remove these boxes\n                points = count * count\n                # Recursively calculate points for the remaining boxes\n                dp[i][j] = points + (dp[i][k] if k >= i else 0) + (dp[j + 1][n - 1] if j + 1 < n else 0)\n\n                # Update max_points\n                max_points = max(max_points, dp[i][j])\n        \n        return max_points\n\n    def public_Remove_Box(self):\n        return self.private_Remove_Box(self.boxes)"}
{"task_id": "OOP/105", "completion": "class AP:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Add_parentheses(self):\n        from itertools import permutations\n\n        def divide(expr):\n            result = eval(expr)\n            return result\n\n        max_value = float('-inf')\n        best_expr = ''\n\n        for perm in permutations(self.nums):\n            expr = str(perm[0])\n            for num in perm[1:]:\n                expr = f\"({expr}/{num})\"\n                value = divide(expr)\n                if value > max_value:\n                    max_value = value\n                    best_expr = expr\n\n        return best_expr\n\n    def public_Add_parentheses(self):\n        return self.private_Add_parentheses()"}
{"task_id": "OOP/106", "completion": "class MI:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Minimum_integer(self):\n        from itertools import permutations\n        \n        digits = list(str(self.n))\n        sorted_permutations = sorted(set(int(''.join(p)) for p in permutations(digits)))\n        for num in sorted_permutations:\n            if num > self.n:\n                return num\n        return -1\n\n    def public_Minimum_integer(self):\n        return self.private_Minimum_integer()"}
{"task_id": "OOP/107", "completion": "class IS:\n    def __init__(self, s):\n        self.s = s\n\n    def __private_Invert_String(self):\n        words = self.s.split(' ')\n        inverted_words = [word[::-1] for word in words]\n        return ' '.join(inverted_words)\n\n    def public_Invert_String(self):\n        return self.__private_Invert_String()"}
{"task_id": "OOP/108", "completion": "class CS:\n    def __init__(self, nums, k):\n        self.nums = nums\n        self.k = k\n\n    def private_Continuous_subarray(self):\n        count = 0\n        cumulative_sum = 0\n        sum_map = {0: 1}\n\n        for num in self.nums:\n            cumulative_sum += num\n            if cumulative_sum - self.k in sum_map:\n                count += sum_map[cumulative_sum - self.k]\n            if cumulative_sum in sum_map:\n                sum_map[cumulative_sum] += 1\n            else:\n                sum_map[cumulative_sum] = 1\n\n        return count\n\n    def public_Continuous_subarray(self):\n        return self.private_Continuous_subarray()"}
{"task_id": "OOP/109", "completion": "class PI:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Palindrome_integer(self):\n        num = int(self.n)\n        lower = num - 1\n        upper = num + 1\n\n        while True:\n            if str(lower) == str(lower)[::-1]:\n                return lower\n            if str(upper) == str(upper)[::-1]:\n                return upper\n            lower -= 1\n            upper += 1\n\n    def public_Palindrome_integer(self):\n        return self.private_Palindrome_integer()"}
{"task_id": "OOP/110", "completion": "class JA:\n    def __init__(self, s1, s2):\n        self.s1 = s1\n        self.s2 = s2\n\n    def __private_Judgment_arrangement(self):\n        return sorted(self.s1) == sorted(self.s2)\n\n    def public_Judgment_arrangement(self):\n        return self.__private_Judgment_arrangement()"}
{"task_id": "OOP/111", "completion": "class SS:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Shortest_subarray(self):\n        n = len(self.nums)\n        left, right = 0, n - 1\n\n        while left < n - 1 and self.nums[left] <= self.nums[left + 1]:\n            left += 1\n        \n        if left == n - 1:\n            return 0\n\n        while right > 0 and self.nums[right] >= self.nums[right - 1]:\n            right -= 1\n\n        min_left = float('inf')\n        max_right = float('-inf')\n        \n        for i in range(left + 1):\n            min_left = min(min_left, self.nums[i])\n        \n        for i in range(right, n):\n            max_right = max(max_right, self.nums[i])\n\n        while left >= 0 and self.nums[left] > min_left:\n            left -= 1\n\n        while right < n and self.nums[right] < max_right:\n            right += 1\n            \n        return right - left - 1\n\n    def public_Shortest_subarray(self):\n        return self.private_Shortest_subarray()"}
{"task_id": "OOP/112", "completion": "class MS:\n    def __init__(self, word1, word2):\n        self.word1 = word1\n        self.word2 = word2\n\n    def __private_Minimum_Steps(self):\n        m, n = len(self.word1), len(self.word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif self.word1[i - 1] == self.word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\n        return dp[m][n]\n\n    def public_Minimum_Steps(self):\n        return self.__private_Minimum_Steps()"}
{"task_id": "OOP/113", "completion": "class RC:\n    def __init__(self, trees):\n        self.trees = trees\n\n    def __private_Return_Coordinates(self):\n        if len(self.trees) <= 1:\n            return self.trees\n\n        # Sort the points lexicographically (by x, then by y)\n        points = sorted(self.trees)\n\n        # Build the lower hull \n        lower = []\n        for p in points:\n            while len(lower) >= 2 and self.__cross(lower[-2], lower[-1], p) <= 0:\n                lower.pop()\n            lower.append(p)\n\n        # Build the upper hull\n        upper = []\n        for p in reversed(points):\n            while len(upper) >= 2 and self.__cross(upper[-2], upper[-1], p) <= 0:\n                upper.pop()\n            upper.append(p)\n\n        # Remove the last point of each half because it's repeated at the beginning of the other half\n        return lower[:-1] + upper[:-1]\n    \n    def __cross(self, o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    def public_Return_Coordinates(self):\n        return self.__private_Return_Coordinates()"}
{"task_id": "OOP/114", "completion": "class MS:\n    def __init__(self, expression):\n        self.expression = expression\n\n    def __private_Minimal_Score(self):\n        from fractions import Fraction\n        tokens = []\n        number = ''\n        for char in self.expression:\n            if char in '+-':\n                if number:\n                    tokens.append(Fraction(int(number)))\n                    number = ''\n                tokens.append(char)\n            else:\n                number += char\n        if number:\n            tokens.append(Fraction(int(number)))\n\n        result = Fraction(0)\n        current_op = '+'\n        for token in tokens:\n            if token in '+-':\n                current_op = token\n            else:\n                if current_op == '+':\n                    result += token\n                elif current_op == '-':\n                    result -= token\n\n        return result\n\n    def public_Minimal_Score(self):\n        result = self.__private_Minimal_Score()\n        return f\"{result.numerator}/{result.denominator}\" if result.denominator != 1 else str(result.numerator) + \"/1\""}
{"task_id": "OOP/115", "completion": "class FAS:\n    def __init__(self, p1, p2, p3, p4):\n        self.p1 = p1\n        self.p2 = p2\n        self.p3 = p3\n        self.p4 = p4\n\n    def __distance_squared(self, p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    def __Form_square(self):\n        dists = [\n            self.__distance_squared(self.p1, self.p2),\n            self.__distance_squared(self.p1, self.p3),\n            self.__distance_squared(self.p1, self.p4),\n            self.__distance_squared(self.p2, self.p3),\n            self.__distance_squared(self.p2, self.p4),\n            self.__distance_squared(self.p3, self.p4)\n        ]\n        dists.sort()\n        return (dists[0] > 0 and \n                dists[0] == dists[1] == dists[2] == dists[3] and \n                dists[4] == dists[5] and \n                dists[0] * 2 == dists[4])\n\n    def public_Form_square(self):\n        return self.__Form_square()"}
{"task_id": "OOP/116", "completion": "class TC:\n    def __init__(self, n):\n        self.n = n\n\n    def __private_There_continuity(self):\n        if self.n < 0:\n            return 0\n        dp = [0] * (self.n + 1)\n        dp[0] = 1  # There is one way to represent 0\n        dp[1] = 2  # Representations: \"0\", \"1\"\n\n        for i in range(2, self.n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n\n        return dp[self.n]\n\n    def public_There_continuity(self):\n        return self.__private_There_continuity()"}
{"task_id": "OOP/117", "completion": "class NOT:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Number_of_triples(self):\n        nums_sorted = sorted(self.nums)\n        count = 0\n        n = len(nums_sorted)\n\n        for i in range(n - 2):\n            k = i + 2\n            for j in range(i + 1, n - 1):\n                while k < n and nums_sorted[i] + nums_sorted[j] > nums_sorted[k]:\n                    k += 1\n                count += k - j - 1\n        \n        return count\n\n    def public_Number_of_triples(self):\n        return self.__private_Number_of_triples()"}
{"task_id": "OOP/118", "completion": "class MT:\n    def __init__(self, tasks, n):\n        self.tasks = tasks\n        self.n = n\n\n    def __private_Minimum_time(self):\n        from collections import Counter\n        task_counts = Counter(self.tasks)\n        max_count = max(task_counts.values())\n        max_count_tasks = sum(1 for count in task_counts.values() if count == max_count)\n\n        # Calculate the number of slots required\n        total_slots = (max_count - 1) * (self.n + 1) + max_count_tasks\n        return max(total_slots, len(self.tasks))\n\n    def public_Minimum_time(self):\n        return self.__private_Minimum_time()"}
{"task_id": "OOP/119", "completion": "class ROP:\n    def __init__(self, n, k):\n        self.n = n\n        self.k = k\n\n    def private_Reverse_order_pair(self):\n        # Create a 2D DP array to store the results\n        dp = [[0] * (self.k + 1) for _ in range(self.n + 1)]\n        dp[0][0] = 1  # Base case: one way to arrange 0 elements with 0 pairs\n\n        for i in range(1, self.n + 1):\n            for j in range(self.k + 1):\n                for m in range(min(j, i - 1) + 1):\n                    dp[i][j] += dp[i - 1][j - m]\n        \n        return dp[self.n][self.k]\n\n    def public_Reverse_order_pair(self):\n        return self.private_Reverse_order_pair()"}
{"task_id": "OOP/120", "completion": "class NCT:\n    def __init__(self, courses):\n        self.courses = courses\n\n    def __private_Number_courses_taken(self):\n        self.courses.sort(key=lambda x: x[1])  # Sort by last day\n        max_courses = 0\n        current_time = 0\n        \n        for duration, last_day in self.courses:\n            if current_time + duration <= last_day:\n                max_courses += 1\n                current_time += duration\n        \n        return max_courses\n\n    def public_Number_courses_taken(self):\n        return self.__private_Number_courses_taken()"}
{"task_id": "OOP/121", "completion": "class JI:\n    def __init__(self, c):\n        self.c = c\n\n    def __private_Judging_integers(self):\n        for a in range(int(self.c**0.5) + 1):\n            b_squared = self.c - a**2\n            if b_squared >= 0:\n                b = int(b_squared**0.5)\n                if b**2 == b_squared:\n                    return True\n        return False\n\n    def public_Judging_integers(self):\n        return self.__private_Judging_integers()"}
{"task_id": "OOP/122", "completion": "class SE:\n    def __init__(self, equation):\n        self.equation = equation\n\n    def private_solve_equation(self):\n        left, right = self.equation.split('=')\n        left_coeff = 0\n        left_var = 0\n        right_coeff = 0\n        right_var = 0\n        \n        def parse_side(side, is_right):\n            coeff = 0\n            var = 0\n            terms = side.replace('-', '+-').split('+')\n            for term in terms:\n                if term == '':\n                    continue\n                if 'x' in term:\n                    term_coeff = term.replace('x', '')\n                    if term_coeff == '' or term_coeff == '+':\n                        var += 1\n                    elif term_coeff == '-':\n                        var -= 1\n                    else:\n                        var += int(term_coeff)\n                else:\n                    coeff += int(term)\n\n            if is_right:\n                return -coeff, -var\n            else:\n                return coeff, var\n\n        left_coeff, left_var = parse_side(left, False)\n        right_coeff, right_var = parse_side(right, True)\n\n        total_var = left_var + right_var\n        total_coeff = right_coeff - left_coeff\n\n        if total_var == 0:\n            if total_coeff == 0:\n                return \"Infinite solutions\"\n            else:\n                return \"No solution\"\n        else:\n            if total_coeff % total_var != 0:\n                return \"No solution\"\n            else:\n                return f\"x={total_coeff // total_var}\"\n\n    def public_solve_equation(self):\n        return self.private_solve_equation()"}
{"task_id": "OOP/123", "completion": "class LPC:\n    def __init__(self, pairs):\n        self.pairs = pairs\n\n    def __private_Longest_pair_chain(self):\n        self.pairs.sort(key=lambda x: x[1])  # Sort pairs based on the second element\n        max_length = 0\n        current_end = float('-inf')  # Initialize the end of the last pair in the chain\n\n        for left, right in self.pairs:\n            if left > current_end:  # If the current pair can follow the last pair\n                max_length += 1\n                current_end = right  # Update the end of the last pair in the chain\n\n        return max_length\n\n    def public_Longest_pair_chain(self):\n        return self.__private_Longest_pair_chain()"}
{"task_id": "OOP/124", "completion": "class PS:\n    def __init__(self, s):\n        self.s = s\n\n    def private_Palindrome_substring(self):\n        count = 0\n        n = len(self.s)\n\n        for center in range(n):\n            # Odd length palindromes\n            left, right = center, center\n            while left >= 0 and right < n and self.s[left] == self.s[right]:\n                count += 1\n                left -= 1\n                right += 1\n\n            # Even length palindromes\n            left, right = center, center + 1\n            while left >= 0 and right < n and self.s[left] == self.s[right]:\n                count += 1\n                left -= 1\n                right += 1\n\n        return count\n\n    def public_Palindrome_substring(self):\n        return self.private_Palindrome_substring()"}
{"task_id": "OOP/125", "completion": "class RS:\n    def __init__(self, dictionary, sentence):\n        self.dictionary = dictionary\n        self.sentence = sentence\n\n    def __private_Root_substitution(self, word):\n        for root in sorted(self.dictionary, key=len):\n            if word.startswith(root):\n                return root\n        return word\n\n    def public_Root_substitution(self):\n        words = self.sentence.split()\n        substituted_words = [self.__private_Root_substitution(word) for word in words]\n        return ' '.join(substituted_words)"}
{"task_id": "OOP/126", "completion": "class MNO:\n    def __init__(self, n):\n        self.n = n\n\n    def __Minimum_operations(self):\n        if self.n == 1:\n            return 0\n        operations = 0\n        for i in range(1, self.n + 1):\n            if self.n % i == 0:\n                operations += i\n        return operations\n\n    def public_Minimum_operations(self):\n        return self.__Minimum_operations()"}
{"task_id": "OOP/127", "completion": "class FPV:\n    def __init__(self, arr, k, x):\n        self.arr = arr\n        self.k = k\n        self.x = x\n\n    def __private_Find_Proximity_Values(self):\n        # Find the k closest numbers to x\n        return sorted(self.arr, key=lambda num: (abs(num - self.x), num))[:self.k]\n\n    def public_Find_Proximity_Values(self):\n        # Call the private function and return its result\n        return self.__private_Find_Proximity_Values()"}
{"task_id": "OOP/128", "completion": "class JudgmentSegmentation:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __private_Judgment_segmentation(self):\n        if len(self.nums) < 3:\n            return False\n            \n        count = 0\n        prev = None\n        last = None\n\n        for num in self.nums:\n            if num == prev + 1:\n                count += 1\n            else:\n                if count < 2 and last is not None:\n                    return False\n                count = 0\n            prev = num\n            last = num\n\n        return count >= 2\n\n    def public_Judgment_segmentation(self):\n        return self.__private_Judgment_segmentation()"}
{"task_id": "OOP/129", "completion": "class MPT:\n    def __init__(self, s):\n        self.s = s\n    \n    def Minimum_Times(self):\n        n = len(self.s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                dp[i][j] = dp[i][j - 1] + 1\n                for k in range(i, j):\n                    if self.s[k] == self.s[j]:\n                        dp[i][j] = min(dp[i][j], dp[i][k] + (1 if k + 1 > j - 1 else 0))\n        \n        return dp[0][n - 1]\n    \n    def public_Minimum_Times(self):\n        return self.Minimum_Times()"}
{"task_id": "OOP/130", "completion": "class NDC:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Non_decreasing_column(self):\n        count = 0\n        for i in range(1, len(self.nums)):\n            if self.nums[i] < self.nums[i - 1]:\n                count += 1\n                if count > 1:\n                    return False\n                if i - 2 < 0 or self.nums[i - 2] <= self.nums[i]:\n                    self.nums[i - 1] = self.nums[i]  # Increase the previous number\n                else:\n                    self.nums[i] = self.nums[i - 1]  # Decrease the current number\n        return True\n\n    def public_Non_decreasing_column(self):\n        return self.private_Non_decreasing_column()"}
{"task_id": "OOP/131", "completion": "class AL:\n    def __init__(self, n, k):\n        self.n = n\n        self.k = k\n\n    def private_Answer_List(self):\n        answer = []\n        if self.k > self.n - 1:\n            return answer\n        \n        diff = list(range(1, self.k + 1))\n        for i in range(self.k):\n            answer.append(i + 1)\n        \n        answer.extend(range(self.k + 1, self.n + 1))\n        \n        return answer\n\n    def public_Answer_List(self):\n        return self.private_Answer_List()"}
{"task_id": "OOP/132", "completion": "class LIS:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def lo_in_sub(self):\n        if not self.nums:\n            return 0\n        dp = [1] * len(self.nums)\n        for i in range(1, len(self.nums)):\n            for j in range(i):\n                if self.nums[i] > self.nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    def public_lo_in_sub(self):\n        return self.lo_in_sub()"}
{"task_id": "OOP/133", "completion": "class CDT:\n    def __init__(self, forest):\n        self.forest = forest\n\n    def private_Chop_down_trees(self, start):\n        from collections import deque\n\n        def bfs(start, target):\n            queue = deque([start])\n            visited = set()\n            visited.add(start)\n            steps = 0\n            \n            while queue:\n                for _ in range(len(queue)):\n                    x, y = queue.popleft()\n                    if (x, y) == target:\n                        return steps\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < len(self.forest) and 0 <= ny < len(self.forest[0]) and (nx, ny) not in visited and self.forest[nx][ny] != 0:\n                            visited.add((nx, ny))\n                            queue.append((nx, ny))\n                steps += 1\n            return -1\n        \n        total_steps = 0\n        trees = []\n        \n        for i in range(len(self.forest)):\n            for j in range(len(self.forest[0])):\n                if self.forest[i][j] > 1:\n                    trees.append((self.forest[i][j], (i, j)))\n        \n        trees.sort()\n        \n        current_position = start\n        \n        for height, position in trees:\n            steps = bfs(current_position, position)\n            if steps == -1:\n                return -1\n            total_steps += steps\n            current_position = position\n            self.forest[current_position[0]][current_position[1]] = 1  # Cut down the tree\n\n        return total_steps\n\n    def public_Chop_down_trees(self):\n        return self.private_Chop_down_trees((0, 0))"}
{"task_id": "OOP/134", "completion": "class VS:\n    def __init__(self, s):\n        self.s = s\n\n    def private_Valid_String(self):\n        stack = []\n        star_count = 0\n\n        for char in self.s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    if star_count > 0:\n                        star_count -= 1\n                    else:\n                        return False\n            elif char == '*':\n                star_count += 1\n\n        return len(stack) <= star_count\n\n    def public_Valid_String(self):\n        return self.private_Valid_String()"}
{"task_id": "OOP/135", "completion": "class ME:\n    def __init__(self, cards):\n        self.cards = cards\n\n    def private_mathematical_expression(self):\n        from itertools import permutations, product\n\n        def valid_expression(num1, num2, operator):\n            if operator == '+':\n                return num1 + num2\n            elif operator == '-':\n                return num1 - num2\n            elif operator == '*':\n                return num1 * num2\n            elif operator == '/':\n                if num2 != 0:\n                    return num1 / num2\n            return None\n\n        def evaluate_expression(nums, ops):\n            result = nums[0]\n            for i in range(3):\n                result = valid_expression(result, nums[i + 1], ops[i])\n                if result is None:\n                    return None\n            return result\n\n        for perm in permutations(self.cards):\n            for ops in product(['+', '-', '*', '/'], repeat=3):\n                # Without parentheses\n                if evaluate_expression(perm, ops) == 24:\n                    return True\n                # With parentheses\n                if evaluate_expression((evaluate_expression((perm[0], perm[1]), (ops[0], ops[1])), perm[2]), (ops[2],)) == 24:\n                    return True\n                if evaluate_expression((perm[0], evaluate_expression((perm[1], perm[2]), (ops[1],))), (ops[0], ops[2])) == 24:\n                    return True\n                if evaluate_expression((perm[0], evaluate_expression((perm[1], perm[2]), (ops[1],))), (ops[0], ops[2])) == 24:\n                    return True\n                if evaluate_expression((perm[0], evaluate_expression((perm[2], perm[3]), (ops[2],))), (ops[0], ops[1])) == 24:\n                    return True\n                if evaluate_expression((evaluate_expression((perm[0], perm[2]), (ops[0],)), perm[3]), (ops[1],)) == 24:\n                    return True\n        return False\n\n    def public_mathematical_expression(self):\n        return self.private_mathematical_expression()"}
{"task_id": "OOP/136", "completion": "class OS:\n    def __init__(self, a: str, b: str):\n        self.a = a\n        self.b = b\n\n    def private_Overlay_substring(self) -> int:\n        if not self.a:\n            return -1\n        \n        # Lengths of the strings\n        len_a = len(self.a)\n        len_b = len(self.b)\n        \n        # Initialize the overlaid string and count of overlays\n        overlay = \"\"\n        count = 0\n        \n        # Keep overlaying until the length of the overlay string is at least the length of b\n        while len(overlay) < len_b + len_a:\n            overlay += self.a\n            count += 1\n            if self.b in overlay:\n                return count\n        \n        return -1\n\n    def public_Overlay_substring(self) -> int:\n        return self.private_Overlay_substring()"}
{"task_id": "OOP/137", "completion": "class KC:\n    def __init__(self, n, k, row, column):\n        self.n = n\n        self.k = k\n        self.row = row\n        self.column = column\n\n    def private_Knight_Chessboard(self, k, row, column):\n        if row < 0 or row >= self.n or column < 0 or column >= self.n:\n            return 0\n        if k == 0:\n            return 1\n        \n        total_ways = 0\n        possible_moves = [\n            (2, 1), (1, 2), (-1, 2), (-2, 1),\n            (-2, -1), (-1, -2), (1, -2), (2, -1)\n        ]\n        \n        for move in possible_moves:\n            total_ways += self.private_Knight_Chessboard(k - 1, row + move[0], column + move[1])\n        \n        return total_ways\n\n    def public_Knight_Chessboard(self):\n        total_ways = self.private_Knight_Chessboard(self.k, self.row, self.column)\n        all_possible_outcomes = 8 ** self.k\n        return total_ways / all_possible_outcomes if all_possible_outcomes != 0 else 0"}
{"task_id": "OOP/138", "completion": "class MS:\n    def __init__(self, nums, k):\n        self.nums = nums\n        self.k = k\n\n    def private_Maximum_subarray(self):\n        n = len(self.nums)\n        if n < 3 * self.k:\n            return []\n\n        # Calculate the sum of first k elements\n        sums = [0] * (n - self.k + 1)\n        current_sum = sum(self.nums[:self.k])\n        sums[0] = current_sum\n\n        # Calculate the sum of all k-length subarrays\n        for i in range(1, n - self.k + 1):\n            current_sum += self.nums[i + self.k - 1] - self.nums[i - 1]\n            sums[i] = current_sum\n\n        max_sum = 0\n        indices = [0, 0, 0]\n\n        # Dynamic programming to find the best indices\n        left_max_index = [0] * (n - self.k + 1)\n        for i in range(n - self.k + 1):\n            if i == 0:\n                left_max_index[i] = 0\n            else:\n                left_max_index[i] = i if sums[i] > sums[left_max_index[i - 1]] else left_max_index[i - 1]\n\n        for j in range(self.k, n - 2 * self.k + 1):\n            first_index = left_max_index[j - self.k]\n            current_sum = sums[first_index] + sums[j] + sums[j + self.k]\n            if current_sum > max_sum:\n                max_sum = current_sum\n                indices = [first_index, j, j + self.k]\n\n        return [self.nums[indices[0]:indices[0] + self.k],\n                self.nums[indices[1]:indices[1] + self.k],\n                self.nums[indices[2]:indices[2] + self.k]]\n\n    def public_Maximum_subarray(self):\n        return self.private_Maximum_subarray()"}
{"task_id": "OOP/139", "completion": "class SW:\n    def __init__(self, stickers, target):\n        self.stickers = stickers\n        self.target = target\n\n    def private_Sticker_Words(self):\n        from collections import Counter\n\n        # Count letters in stickers and target\n        sticker_count = [Counter(sticker) for sticker in self.stickers]\n        target_count = Counter(self.target)\n\n        # Initialize dp array\n        dp = {tuple(target_count.items()): 0}\n\n        # Algorithm to find the minimum number of stickers\n        def dfs(current_target):\n            if tuple(current_target.items()) in dp:\n                return dp[tuple(current_target.items())]\n\n            # If target is empty\n            if not current_target:\n                return 0\n\n            # Initialize minimum stickers required\n            min_stickers = float('inf')\n            \n            for sticker in sticker_count:\n                # Skip if the sticker can't help with the target\n                if sticker[current_target.most_common(1)[0][0]] == 0:\n                    continue\n                \n                # Create a new target count after using the sticker\n                new_target = current_target.copy()\n                \n                for char in sticker:\n                    if char in new_target:\n                        new_target[char] = max(0, new_target[char] - sticker[char])\n\n                # Recur for new target\n                res = dfs(new_target)\n                if res != -1:\n                    min_stickers = min(min_stickers, res + 1)\n\n            # Save to dp\n            dp[tuple(current_target.items())] = min_stickers if min_stickers != float('inf') else -1\n            return dp[tuple(current_target.items())]\n\n        return dfs(target_count)\n\n    def public_Sticker_Words(self):\n        return self.private_Sticker_Words()"}
{"task_id": "OOP/140", "completion": "class MT:\n    def __init__(self, words, k):\n        self.words = words\n        self.k = k\n\n    def __private_Most_times(self):\n        from collections import Counter\n        word_count = Counter(self.words)\n        most_common = word_count.most_common(self.k)\n        return [word for word, count in most_common]\n\n    def public_Most_times(self):\n        return self.__private_Most_times()"}
{"task_id": "OOP/141", "completion": "class AA:\n    def __init__(self, n):\n        self.n = n\n\n    def private_Alternating_appearance(self):\n        binary_representation = bin(self.n)[2:]\n        for i in range(len(binary_representation) - 1):\n            if binary_representation[i] == binary_representation[i + 1]:\n                return False\n        return True\n\n    def public_Alternating_appearance(self):\n        return self.private_Alternating_appearance()"}
{"task_id": "OOP/142", "completion": "class IA:\n    def __init__(self, grid):\n        self.grid = grid\n\n    def private_Island_area(self, x, y):\n        if x < 0 or x >= len(self.grid) or y < 0 or y >= len(self.grid[0]) or self.grid[x][y] == 0:\n            return 0\n        # Mark the cell as visited\n        self.grid[x][y] = 0\n        area = 1\n        # Explore all four directions\n        area += self.private_Island_area(x + 1, y)\n        area += self.private_Island_area(x - 1, y)\n        area += self.private_Island_area(x, y + 1)\n        area += self.private_Island_area(x, y - 1)\n        return area\n\n    def public_Island_area(self):\n        max_area = 0\n        for i in range(len(self.grid)):\n            for j in range(len(self.grid[0])):\n                if self.grid[i][j] == 1:\n                    current_area = self.private_Island_area(i, j)\n                    max_area = max(max_area, current_area)\n        return max_area"}
{"task_id": "OOP/143", "completion": "class ES:\n    def __init__(self, nums, k):\n        self.nums = nums\n        self.k = k\n\n    def private_Equal_sum(self):\n        total_sum = sum(self.nums)\n        if total_sum % self.k != 0:\n            return False\n        \n        target_sum = total_sum // self.k\n        used = [False] * len(self.nums)\n\n        def can_partition(start, current_sum, count):\n            if count == self.k - 1:\n                return True\n            if current_sum == target_sum:\n                return can_partition(0, 0, count + 1)\n            for i in range(start, len(self.nums)):\n                if not used[i] and current_sum + self.nums[i] <= target_sum:\n                    used[i] = True\n                    if can_partition(i + 1, current_sum + self.nums[i], count):\n                        return True\n                    used[i] = False\n            return False\n\n        return can_partition(0, 0, 0)\n\n    def public_Equal_sum(self):\n        return self.private_Equal_sum()"}
{"task_id": "OOP/144", "completion": "class BS:\n    def __init__(self, positions):\n        self.positions = positions\n\n    def __private_Block_stacking(self):\n        max_height = 0\n        heights = []\n\n        for left, side_length in self.positions:\n            right = left + side_length\n            current_height = 0\n\n            for i in range(len(heights)):\n                existing_left = self.positions[i][0]\n                existing_side_length = self.positions[i][1]\n                existing_right = existing_left + existing_side_length\n\n                if not (right <= existing_left or left >= existing_right):  # They overlap\n                    current_height = max(current_height, heights[i])\n\n            current_height += side_length\n            heights.append(current_height)\n            max_height = max(max_height, current_height)\n\n        return max_height\n\n    def public_Block_stacking(self):\n        return self.__private_Block_stacking()"}
{"task_id": "OOP/145", "completion": "class DC:\n    def __init__(self, s1, s2):\n        self.s1 = s1\n        self.s2 = s2\n        \n    def __private_Delete_Characters(self):\n        freq_s1 = {}\n        freq_s2 = {}\n        \n        for char in self.s1:\n            freq_s1[char] = freq_s1.get(char, 0) + 1\n            \n        for char in self.s2:\n            freq_s2[char] = freq_s2.get(char, 0) + 1\n            \n        total_ascii_sum = 0\n        \n        for char in freq_s1:\n            if char not in freq_s2:\n                total_ascii_sum += ord(char) * freq_s1[char]\n        \n        for char in freq_s2:\n            if char not in freq_s1:\n                total_ascii_sum += ord(char) * freq_s2[char]\n        \n        return total_ascii_sum\n    \n    def public_Delete_Characters(self):\n        return self.__private_Delete_Characters()"}
{"task_id": "OOP/146", "completion": "class POE:\n    def __init__(self, nums, k):\n        self.nums = nums\n        self.k = k\n\n    def private_Product_of_elements(self):\n        if self.k <= 1:\n            return 0\n        \n        count = 0\n        product = 1\n        left = 0\n        \n        for right in range(len(self.nums)):\n            product *= self.nums[right]\n            while product >= self.k:\n                product //= self.nums[left]\n                left += 1\n            count += right - left + 1\n            \n        return count\n\n    def public_Product_of_elements(self):\n        return self.private_Product_of_elements()"}
{"task_id": "OOP/147", "completion": "class BS:\n    def __init__(self, prices, fee):\n        self.prices = prices\n        self.fee = fee\n\n    def __private_buy_share(self):\n        cash = 0\n        hold = -self.prices[0]  # Buying stock on the first day\n        \n        for price in self.prices:\n            cash = max(cash, hold + price - self.fee)  # Sell stock\n            hold = max(hold, cash - price)  # Buy stock again\n        \n        return cash\n\n    def public_buy_share(self):\n        return self.__private_buy_share()"}
{"task_id": "OOP/148", "completion": "class BC:\n    def __init__(self, bits):\n        self.bits = bits\n\n    def private_Bit_character(self):\n        count = 0\n        i = 0\n        while i < len(self.bits):\n            if self.bits[i] == 0:\n                count += 1\n                i += 1\n            else:\n                count += 1\n                i += 2\n        return count % 2 == 1\n\n    def public_Bit_character(self):\n        return self.private_Bit_character() and self.bits[-1] == 0"}
{"task_id": "OOP/149", "completion": "class BL:\n    def __init__(self, nums1, nums2):\n        self.nums1 = nums1\n        self.nums2 = nums2\n\n    def private_BLongest_length(self):\n        m, n = len(self.nums1), len(self.nums2)\n        max_length = 0\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if self.nums1[i - 1] == self.nums2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    max_length = max(max_length, dp[i][j])\n\n        return max_length\n\n    def public_BLongest_length(self):\n        return self.private_BLongest_length()"}
{"task_id": "OOP/150", "completion": "class AD:\n    def __init__(self, nums, k):\n        self.nums = nums\n        self.k = k\n\n    def private_absolute_difference(self):\n        distances = []\n        n = len(self.nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                distances.append(abs(self.nums[i] - self.nums[j]))\n        distances.sort()\n        return distances[self.k - 1]\n\n    def public_absolute_difference(self):\n        return self.private_absolute_difference()"}
{"task_id": "OOP/151", "completion": "class ED:\n    def __init__(self, words):\n        self.words = set(words)\n\n    def private_English_Dictionary(self):\n        sorted_words = sorted(self.words)\n        longest_word = \"\"\n        current_word = \"\"\n\n        for word in sorted_words:\n            if len(word) == len(current_word) + 1 and current_word in self.words:\n                current_word = word\n            elif len(word) == 1:\n                current_word = word\n            \n            if len(current_word) > len(longest_word):\n                longest_word = current_word\n            elif len(current_word) == len(longest_word) and current_word < longest_word:\n                longest_word = current_word\n\n        return longest_word\n\n    def public_English_Dictionary(self):\n        return self.private_English_Dictionary()"}
{"task_id": "OOP/152", "completion": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass LS:\n    def __init__(self, head, k):\n        self.head = head\n        self.k = k\n\n    def private_List_separation(self):\n        length = 0\n        current = self.head\n        while current:\n            length += 1\n            current = current.next\n        \n        part_length = length // self.k\n        remainder = length % self.k\n        \n        parts = []\n        current = self.head\n        \n        for i in range(self.k):\n            parts.append(current)\n            current_length = part_length + (1 if i < remainder else 0)\n            for j in range(current_length):\n                if current:\n                    current = current.next\n            if current_length > 0:\n                current.next = None\n        \n        return parts\n\n    def public_List_separation(self):\n        return self.private_List_separation()"}
{"task_id": "OOP/153", "completion": "class NOS:\n    def __init__(self, s):\n        self.s = s\n\n    def private_Number_of_sequences(self):\n        n = len(self.s)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = 1\n\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if self.s[i] == self.s[j]:\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + 1\n                else:\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n\n        return dp[0][n - 1]\n\n    def public_Number_of_sequences(self):\n        return self.private_Number_of_sequences()"}
{"task_id": "OOP/154", "completion": "class MI:\n    def __init__(self, n):\n        self.n = n\n\n    def private_monotonic_increase(self):\n        num_str = str(self.n)\n        length = len(num_str)\n        result = list(num_str)\n        \n        for i in range(length - 1, 0, -1):\n            if result[i] < result[i - 1]:\n                result[i - 1] = str(int(result[i - 1]) - 1)\n                for j in range(i, length):\n                    result[j] = '9'\n                break\n        \n        return int(''.join(result))\n\n    def public_monotonic_increase(self):\n        return self.private_monotonic_increase()"}
{"task_id": "OOP/155", "completion": "class TR:\n    def __init__(self, temperatures):\n        self.temperatures = temperatures\n\n    def private_Temperature_rise(self):\n        n = len(self.temperatures)\n        answer = [0] * n\n        stack = []\n\n        for i in range(n):\n            while stack and self.temperatures[i] > self.temperatures[stack[-1]]:\n                idx = stack.pop()\n                answer[idx] = i - idx\n            stack.append(i)\n\n        return answer\n\n    def public_Temperature_rise(self):\n        return self.private_Temperature_rise()"}
{"task_id": "OOP/156", "completion": "class MN:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Maximum_number(self):\n        from collections import Counter\n        \n        count = Counter(self.nums)\n        max_num = max(count.keys())\n        dp = [0] * (max_num + 1)\n\n        dp[0] = 0\n        dp[1] = count[1] * 1\n\n        for i in range(2, max_num + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2] + count[i] * i)\n        \n        return dp[max_num]\n\n    def public_Maximum_number(self):\n        return self.private_Maximum_number()"}
{"task_id": "OOP/157", "completion": "class NN:\n    def __init__(self, times, n, k):\n        self.times = times\n        self.n = n\n        self.k = k\n\n    def __private_network_node(self):\n        import heapq\n        from collections import defaultdict\n\n        graph = defaultdict(list)\n        for u, v, w in self.times:\n            graph[u].append((v, w))\n\n        min_time = {i: float('inf') for i in range(1, self.n + 1)}\n        min_time[self.k] = 0\n        priority_queue = [(0, self.k)]\n\n        while priority_queue:\n            current_time, node = heapq.heappop(priority_queue)\n\n            if current_time > min_time[node]:\n                continue\n\n            for neighbor, time in graph[node]:\n                new_time = current_time + time\n                if new_time < min_time[neighbor]:\n                    min_time[neighbor] = new_time\n                    heapq.heappush(priority_queue, (new_time, neighbor))\n\n        max_time = max(min_time.values())\n        return max_time if max_time < float('inf') else -1\n\n    def public_network_node(self):\n        return self.__private_network_node()"}
{"task_id": "OOP/158", "completion": "class INA:\n    def __init__(self, target):\n        self.target = target\n\n    def private_Infinite_number_axis(self):\n        target = abs(self.target)\n        numMoves = 0\n        total_steps = 0\n        \n        while total_steps < target or (total_steps - target) % 2 != 0:\n            numMoves += 1\n            total_steps += numMoves\n        \n        return numMoves\n\n    def public_Infinite_number_axis(self):\n        return self.private_Infinite_number_axis()"}
{"task_id": "OOP/159", "completion": "class IC:\n    def __init__(self, intervals):\n        self.intervals = intervals\n\n    def private_Include_Collection(self):\n        nums = set()\n        for start, end in sorted(self.intervals, key=lambda x: x[1]):\n            while len(nums) < 2 * len(nums) - 1 and len(nums) < end - start + 1:\n                nums.add(end)\n                if len(nums) < 2:\n                    nums.add(end - 1)\n        return len(nums)\n\n    def public_Include_Collection(self):\n        return self.private_Include_Collection()"}
{"task_id": "OOP/160", "completion": "class SP:\n    def __init__(self, s):\n        self.s = s\n\n    def private_String_partitioning(self):\n        last_index = {char: idx for idx, char in enumerate(self.s)}\n        partitions = []\n        start = 0\n        end = 0\n        \n        for i, char in enumerate(self.s):\n            end = max(end, last_index[char])\n            if i == end:\n                partitions.append(end - start + 1)\n                start = i + 1\n        \n        return partitions\n\n    def public_String_partitioning(self):\n        return self.private_String_partitioning()"}
{"task_id": "OOP/161", "completion": "class PS:\n    def __init__(self, n, mines):\n        self.n = n\n        self.mines = mines\n        self.grid = [[1] * n for _ in range(n)]\n        for x, y in mines:\n            self.grid[x][y] = 0\n\n    def private_Plus_sign(self):\n        order = 0\n        dp = [[[0] * 4 for _ in range(self.n)] for _ in range(self.n)]\n\n        for i in range(self.n):\n            for j in range(self.n):\n                if self.grid[i][j] == 1:\n                    dp[i][j][0] = dp[i - 1][j][0] + 1 if i > 0 else 1  # up\n                    dp[i][j][1] = dp[i][j - 1][1] + 1 if j > 0 else 1  # left\n\n        for i in range(self.n - 1, -1, -1):\n            for j in range(self.n - 1, -1, -1):\n                if self.grid[i][j] == 1:\n                    dp[i][j][2] = dp[i + 1][j][2] + 1 if i < self.n - 1 else 1  # down\n                    dp[i][j][3] = dp[i][j + 1][3] + 1 if j < self.n - 1 else 1  # right\n\n        for i in range(self.n):\n            for j in range(self.n):\n                if self.grid[i][j] == 1:\n                    order = max(order, min(dp[i][j][0], dp[i][j][1], dp[i][j][2], dp[i][j][3]))\n\n        return order\n\n    def public_Plus_sign(self):\n        return self.private_Plus_sign()"}
{"task_id": "OOP/162", "completion": "class ES:\n    def __init__(self, row):\n        self.row = row\n    \n    def private_Exchange_seats(self):\n        positions = {person: i for i, person in enumerate(self.row)}\n        swaps = 0\n        \n        for i in range(0, len(self.row), 2):\n            couple_id = self.row[i] // 2 * 2  # Get the couple id (0 or 2 for 0-1, 2-3 etc.)\n            if self.row[i] != couple_id:  # If the current position doesn't have the right person\n                swaps += 1\n                swap_idx = positions[couple_id]  # Find where the right person is sitting\n                self.row[i], self.row[swap_idx] = self.row[swap_idx], self.row[i]  # Swap them\n                positions[self.row[swap_idx]] = swap_idx  # Update the position of the swapped person\n                positions[couple_id] = i  # Update the position of the couple id\n        \n        return swaps\n    \n    def public_Exchange_seats(self):\n        return self.private_Exchange_seats()"}
{"task_id": "OOP/163", "completion": "class JM:\n    def __init__(self, matrix):\n        self.matrix = matrix\n\n    def __private_judgment_matrix(self):\n        if not self.matrix:\n            return True\n        rows = len(self.matrix)\n        cols = len(self.matrix[0])\n        \n        for r in range(rows - 1):\n            for c in range(cols - 1):\n                if self.matrix[r][c] != self.matrix[r + 1][c + 1]:\n                    return False\n        return True\n\n    def public_judgment_matrix(self):\n        return self.__private_judgment_matrix()"}
{"task_id": "OOP/164", "completion": "class RL:\n    def __init__(self, s):\n        self.s = s\n    \n    def __private_Rearrange_letters(self):\n        from collections import Counter\n        count = Counter(self.s)\n        max_freq = max(count.values())\n        if max_freq > (len(self.s) + 1) // 2:\n            return \"\"\n        \n        result = []\n        sorted_items = sorted(count.items(), key=lambda x: -x[1])\n        \n        for char, freq in sorted_items:\n            result.extend([char] * freq)\n        \n        rearranged = [''] * len(self.s)\n        index = 0\n        \n        for char in result:\n            rearranged[index] = char\n            index += 2\n            if index >= len(self.s):\n                index = 1\n        \n        return ''.join(rearranged)\n    \n    def public_Rearrange_letters(self):\n        return self.__private_Rearrange_letters()"}
{"task_id": "OOP/165", "completion": "class MNB:\n    def __init__(self, arr):\n        self.arr = arr\n\n    def __private_Maximum_number_blocks(self):\n        sorted_arr = sorted(self.arr)\n        max_chunks = 0\n        current_max = 0\n        \n        for i in range(len(self.arr)):\n            current_max = max(current_max, self.arr[i])\n            if current_max == sorted_arr[i]:\n                max_chunks += 1\n        \n        return max_chunks\n\n    def public_Maximum_number_blocks(self):\n        return self.__private_Maximum_number_blocks()"}
{"task_id": "OOP/166", "completion": "class SS:\n    def __init__(self, arr):\n        self.arr = arr\n\n    def __private_Sort_separately(self):\n        blocks = []\n        n = len(self.arr)\n        visited = [False] * n\n\n        for i in range(n):\n            if not visited[i]:\n                block = []\n                while not visited[i]:\n                    block.append(self.arr[i])\n                    visited[i] = True\n                    i = self.arr[i]\n                blocks.append(block)\n\n        return blocks\n\n    def public_Sort_separately(self):\n        blocks = self.__private_Sort_separately()\n        sorted_blocks = [sorted(block) for block in blocks]\n        \n        # Reconstruct the sorted array from the sorted blocks\n        block_idx = 0\n        sorted_arr = []\n\n        for block in sorted_blocks:\n            sorted_arr.extend(block)\n\n        return sorted_arr, len(blocks)"}
{"task_id": "OOP/167", "completion": "class SPB:\n    def __init__(self, board):\n        self.board = board\n\n    def private_Solving_puzzle_board(self):\n        from collections import deque\n        \n        def get_zero_position(b):\n            for i in range(2):\n                for j in range(3):\n                    if b[i][j] == 0:\n                        return (i, j)\n\n        def is_solvable(b):\n            flat_b = [num for row in b for num in row if num != 0]\n            inv_count = sum(1 for i in range(len(flat_b)) for j in range(i + 1, len(flat_b)) if flat_b[i] > flat_b[j])\n            return inv_count % 2 == 0\n\n        def board_to_string(b):\n            return ''.join(str(num) for row in b for num in row)\n\n        target = [[1, 2, 3], [4, 5, 0]]\n        target_str = board_to_string(target)\n\n        if not is_solvable(self.board):\n            return -1\n        \n        start = board_to_string(self.board)\n        queue = deque([(start, get_zero_position(self.board), 0)])  # (board string, zero position, moves)\n        visited = {start}\n\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n\n        while queue:\n            current, (x, y), moves = queue.popleft()\n\n            if current == target_str:\n                return moves\n            \n            for dx, dy in directions:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < 2 and 0 <= new_y < 3:\n                    new_board = list(current)\n                    new_zero_index = x * 3 + y\n                    new_num_index = new_x * 3 + new_y\n                    new_board[new_zero_index], new_board[new_num_index] = new_board[new_num_index], new_board[new_zero_index]\n                    new_board_str = ''.join(new_board)\n\n                    if new_board_str not in visited:\n                        visited.add(new_board_str)\n                        queue.append((new_board_str, (new_x, new_y), moves + 1))\n        \n        return -1\n\n    def public_Solving_puzzle_board(self):\n        return self.private_Solving_puzzle_board()"}
{"task_id": "OOP/168", "completion": "class LI:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def private_Local_inversion(self):\n        global_inv = sum(1 for i in range(len(self.nums)) for j in range(i + 1, len(self.nums)) if self.nums[i] > self.nums[j])\n        local_inv = sum(1 for i in range(len(self.nums) - 1) if self.nums[i] > self.nums[i + 1])\n        return global_inv == local_inv\n\n    def public_Local_inversion(self):\n        return self.private_Local_inversion()"}
{"task_id": "OOP/169", "completion": "class GS:\n    def __init__(self, grid):\n        self.grid = grid\n    \n    def private_Grid_swimming(self, t):\n        n = len(self.grid)\n        if n == 0 or n != len(self.grid[0]):\n            return -1  # Invalid grid\n        \n        if self.grid[0][0] > t or self.grid[n-1][n-1] > t:\n            return -1  # Cannot start or end\n        \n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        visited = set()\n        queue = [(0, 0)]\n        visited.add((0, 0))\n        minutes = 0\n        \n        while queue:\n            temp = []\n            for x, y in queue:\n                if x == n - 1 and y == n - 1:\n                    return minutes\n                \n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    \n                    if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                        if self.grid[nx][ny] <= t:\n                            visited.add((nx, ny))\n                            temp.append((nx, ny))\n                        \n            queue = temp\n            minutes += 1\n        \n        return -1  # If there is no way to reach the bottom-right corner\n    \n    def public_Grid_swimming(self, t):\n        return self.private_Grid_swimming(t)"}
{"task_id": "OOP/170", "completion": "class GNR:\n    def __init__(self, n, k):\n        self.n = n\n        self.k = k\n\n    def private_Given_number_rows(self):\n        if self.n == 1:\n            return '0'\n        else:\n            previous_row = self.private_Given_number_rows_helper(self.n - 1)\n            new_row = ''\n            for char in previous_row:\n                if char == '0':\n                    new_row += '01'\n                else:\n                    new_row += '10'\n            return new_row\n    \n    def public_Given_number_rows(self):\n        result_row = self.private_Given_number_rows()\n        return result_row[self.k - 1]  # k is indexed from 1, so subtract 1 for 0-indexing\n\n    def private_Given_number_rows_helper(self, n):\n        if n == 1:\n            return '0'\n        else:\n            previous_row = self.private_Given_number_rows_helper(n - 1)\n            new_row = ''\n            for char in previous_row:\n                if char == '0':\n                    new_row += '01'\n                else:\n                    new_row += '10'\n            return new_row"}
{"task_id": "OOP/171", "completion": "class CN:\n    def __init__(self, sx, sy, tx, ty):\n        self.sx = sx\n        self.sy = sy\n        self.tx = tx\n        self.ty = ty\n\n    def private_Convert_numbers(self):\n        while self.tx > self.sx and self.ty > self.sy:\n            if self.tx > self.ty:\n                self.tx -= self.ty\n            else:\n                self.ty -= self.tx\n        return (self.tx == self.sx and self.ty >= self.sy and (self.ty - self.sy) % self.sx == 0) or \\\n               (self.ty == self.sy and self.tx >= self.sx and (self.tx - self.sx) % self.sy == 0)\n\n    def public_Convert_numbers(self):\n        return self.private_Convert_numbers()"}
{"task_id": "OOP/172", "completion": "class FR:\n    def __init__(self, answers):\n        self.answers = answers\n\n    def private_Forest_Rabbit(self):\n        from collections import Counter\n        count = Counter(self.answers)\n        total_rabbits = 0\n        \n        for color_count, frequency in count.items():\n            # Each unique color answers how many of their kind they see,\n            # which means they (themselves included) must account for their count.\n            total_rabbits += (color_count + 1) * ((frequency + color_count) // (color_count + 1))\n        \n        return total_rabbits\n\n    def public_Forest_Rabbit(self):\n        return self.private_Forest_Rabbit()"}
{"task_id": "OOP/173", "completion": "class NM:\n    def __init__(self, board):\n        self.board = board\n\n    def private_Network_Matrix(self):\n        n = len(self.board)\n        row_counts = [[0, 0] for _ in range(2)]\n        col_counts = [[0, 0] for _ in range(2)]\n\n        for i in range(n):\n            for j in range(n):\n                row_counts[i % 2][self.board[i][j]] += 1\n                col_counts[j % 2][self.board[i][j]] += 1\n\n        row_moves = self.calculate_moves(row_counts, n)\n        col_moves = self.calculate_moves(col_counts, n)\n\n        if row_moves == -1 or col_moves == -1:\n            return -1\n        return row_moves + col_moves\n\n    def calculate_moves(self, counts, n):\n        if counts[0][0] + counts[1][0] != n // 2 or counts[0][1] + counts[1][1] != n // 2:\n            return -1\n        return abs(counts[0][0] - counts[1][1]) // 2 + abs(counts[0][1] - counts[1][0]) // 2\n\n    def public_Network_Matrix(self):\n        return self.private_Network_Matrix()"}
{"task_id": "OOP/174", "completion": "class CC:\n    def __init__(self, s):\n        self.s = s\n\n    def private_Change_Case(self, index=0, path=''):\n        if index == len(self.s):\n            return {path}\n        \n        current_char = self.s[index]\n        result = set()\n\n        # Add lowercase version\n        result.update(self.private_Change_Case(index + 1, path + current_char.lower()))\n        # Add uppercase version\n        result.update(self.private_Change_Case(index + 1, path + current_char.upper()))\n\n        return result\n\n    def public_Change_Case(self):\n        return self.private_Change_Case()"}
{"task_id": "OOP/175", "completion": "class MS:\n    def __init__(self, arr, k):\n        self.arr = arr\n        self.k = k\n\n    def private_Minimum_score(self):\n        scores = []\n        n = len(self.arr)\n        for i in range(n):\n            for j in range(i + 1, n):\n                score = self.arr[i] / self.arr[j]\n                scores.append(score)\n        scores.sort()\n        return scores[self.k - 1]\n\n    def public_Minimum_score(self):\n        return self.private_Minimum_score()"}
{"task_id": "OOP/176", "completion": "class PM:\n    def __init__(self, order: str, s: str):\n        self.order = order\n        self.s = s\n\n    def private_Permutation_matching(self):\n        order_index = {char: i for i, char in enumerate(self.order)}\n        sorted_s = sorted(self.s, key=lambda char: order_index.get(char, len(self.order)))\n        return ''.join(sorted_s)\n\n    def public_Permutation_matching(self):\n        return self.private_Permutation_matching()"}
{"task_id": "OOP/177", "completion": "class NW:\n    def __init__(self, s, words):\n        self.s = s\n        self.words = words\n\n    def __private_Number_words(self):\n        def is_subsequence(word, s):\n            it = iter(s)\n            return all(char in it for char in word)\n\n        count = 0\n        for word in self.words:\n            if is_subsequence(word, self.s):\n                count += 1\n        return count\n\n    def public_Number_words(self):\n        return self.__private_Number_words()"}
{"task_id": "OOP/178", "completion": "class NI:\n    def __init__(self, k):\n        self.k = k\n\n    def private_nonnegative_integer(self):\n        low, high = 0, 5 * self.k + 1\n        result = 0\n\n        while low <= high:\n            mid = (low + high) // 2\n            zeros = self.count_trailing_zeros(mid)\n\n            if zeros < self.k:\n                low = mid + 1\n            elif zeros > self.k:\n                high = mid - 1\n            else:\n                result += 1\n                # Count how many consecutive numbers fulfill f(x) = k\n                left = mid - 1\n                right = mid + 1\n\n                while left >= 0 and self.count_trailing_zeros(left) == self.k:\n                    result += 1\n                    left -= 1\n\n                while self.count_trailing_zeros(right) == self.k:\n                    result += 1\n                    right += 1\n\n                break\n\n        return result\n\n    def count_trailing_zeros(self, x):\n        count = 0\n        while x >= 5:\n            x //= 5\n            count += x\n        return count\n\n    def public_nonnegative_integer(self):\n        return self.private_nonnegative_integer()"}
