{"task_id": "OOP/0", "completion": "class FDSB:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_FDSB(FDSB):\n    def __init__(self, nums, left, right):\n        super().__init__(nums)\n        self.left = left\n        self.right = right\n\n    def find_subarray(self):\n        count = 0\n        n = len(self.nums)\n        \n        for start in range(n):\n            max_element = self.nums[start]\n            for end in range(start, n):\n                max_element = max(max_element, self.nums[end])\n                if max_element > self.right:\n                    break\n                if self.left <= max_element <= self.right:\n                    count += 1\n        \n        return count", "result": "passed", "passed": true}
{"task_id": "OOP/1", "completion": "class FDSB:\n    def __init__(self, nums):\n        self.nums = nums\n\n\nclass SN_FDSB(FDSB):\n    def __init__(self, nums, left, right):\n        super().__init__(nums)\n        self.left = left\n        self.right = right\n\n    def find_subarray(self):\n        count = 0\n        n = len(self.nums)\n        start = 0\n\n        while start < n:\n            # Move the end pointer to find a valid range\n            end = start\n            max_in_range = float('-inf')\n\n            while end < n and self.nums[end] <= self.right:\n                max_in_range = max(max_in_range, self.nums[end])\n\n                if max_in_range > self.right:\n                    break\n\n                if self.left <= max_in_range <= self.right:\n                    count += 1\n\n                end += 1\n\n            start += 1\n\n        return count", "result": "passed", "passed": true}
{"task_id": "OOP/2", "completion": "class PO:\n    def __init__(self, graph):\n        self.graph = graph\n\nclass SN_PO(PO):\n    def Path_output(self):\n        def dfs(current_node, path):\n            if current_node == len(self.graph) - 1:\n                paths.append(list(path))\n                return\n            for neighbor in self.graph[current_node]:\n                path.append(neighbor)\n                dfs(neighbor, path)\n                path.pop()\n\n        paths = []\n        dfs(0, [0])\n        return paths", "result": "failed: ", "passed": false}
{"task_id": "OOP/3", "completion": "class EE:\n    def __init__(self, nums1):\n        self.nums1 = nums1\n\nclass SN_EE(EE):\n    def __init__(self, nums1, nums2):\n        super().__init__(nums1)\n        self.nums2 = nums2\n\n    def Exchange_Elements(self):\n        n = len(self.nums1)\n        swap = 0\n        \n        # Previous values for comparison\n        prev1, prev2 = float('-inf'), float('-inf')\n        \n        for i in range(n):\n            # Current elements\n            a = self.nums1[i]\n            b = self.nums2[i]\n\n            # Check if we can keep nums1[i]\n            if a > prev1:\n                prev1 = a\n            elif b > prev1:\n                prev1 = b\n                swap += 1\n            else:\n                # If neither works, we cannot make a strictly increasing sequence\n                return float('inf')\n\n            # Check if we can keep nums2[i]\n            if b > prev2:\n                prev2 = b\n            elif a > prev2:\n                prev2 = a\n                swap += 1\n            else:\n                # If neither works, we cannot make a strictly increasing sequence\n                return float('inf')\n        \n        return swap", "result": "passed", "passed": true}
{"task_id": "OOP/4", "completion": "class SND:\n    def __init__(self, graph):\n        self.graph = graph\n\nclass SN_SND(SND):\n    def secure_node(self):\n        n = len(self.graph)\n        # This will store the state of each node: 0 = unknown, 1 = safe, -1 = unsafe\n        state = [0] * n\n        \n        def is_safe(node):\n            if state[node] != 0:\n                return state[node] == 1  # Return true if the node is safe\n            state[node] = -1  # Mark as checking (unsafe)\n            for neighbor in self.graph[node]:\n                if not is_safe(neighbor):\n                    return False\n            state[node] = 1  # Mark as safe\n            return True\n        \n        safe_nodes = []\n        for i in range(n):\n            if is_safe(i):\n                safe_nodes.append(i)\n        \n        return sorted(safe_nodes)", "result": "failed: ", "passed": false}
{"task_id": "OOP/5", "completion": "class NBS:\n    def __init__(self, grid):\n        self.grid = grid\n\n    def is_stable(self, row, col):\n        if row < 0 or col < 0 or row >= len(self.grid) or col >= len(self.grid[0]):\n            return False\n        return self.grid[row][col] == 1\n\n    def dfs(self, row, col):\n        if not self.is_stable(row, col):\n            return 0\n        self.grid[row][col] = 0\n        count = 1\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            count += self.dfs(row + dr, col + dc)\n        return count\n\nclass SN_NBS(NBS):\n    def __init__(self, grid, hits):\n        super().__init__(grid)\n        self.hits = hits\n\n    def Number_bricks(self):\n        result = []\n        for row, col in self.hits:\n            if self.grid[row][col] == 0:\n                result.append(0)\n                continue\n            \n            self.grid[row][col] = 1  # Restore the brick temporarily\n            if row == 0 or any(self.is_stable(row + dr, col + dc) for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]):\n                stable_count = self.dfs(row, col)\n                result.append(stable_count - 1)  # Exclude the restored brick itself\n            else:\n                result.append(0)\n                self.grid[row][col] = 0  # Restore again to the original state\n                continue\n            \n            self.grid[row][col] = 0  # Eliminate the brick after counting\n        return result", "result": "failed: ", "passed": false}
{"task_id": "OOP/6", "completion": "class EMT:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_EMT(EMT):\n    def Element_Movement(self):\n        total_sum = sum(self.nums)\n        total_count = len(self.nums)\n\n        for i in range(1, 1 << total_count):\n            A = []\n            B = []\n            for j in range(total_count):\n                if i & (1 << j):\n                    A.append(self.nums[j])\n                else:\n                    B.append(self.nums[j])\n            if A and B:\n                if sum(A) * len(B) == sum(B) * len(A):\n                    return True\n        return False", "result": "failed: ", "passed": false}
{"task_id": "OOP/7", "completion": "class MSE:\n    def __init__(self, nums):\n        self.nums = nums\n\n\nclass SN_MSE(MSE):\n    def __init__(self, nums, k):\n        super().__init__(nums)\n        self.k = k\n\n    def Maximum_score(self):\n        n = len(self.nums)\n        if self.k <= 0 or n == 0:\n            return 0\n        \n        # Create a prefix sum array\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + self.nums[i]\n\n        # Create a dp array for maximum score\n        dp = [[0] * (self.k + 1) for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            dp[i][1] = prefix_sum[i] / i  # One subarray from 0 to i-1\n\n        for j in range(2, self.k + 1):  # For each possible number of subarrays\n            for i in range(1, n + 1):  # For each possible endpoint\n                for p in range(i):  # Consider every possible split\n                    average = (prefix_sum[i] - prefix_sum[p]) / (i - p)\n                    dp[i][j] = max(dp[i][j], dp[p][j - 1] + average)\n\n        return dp[n][self.k]", "result": "passed", "passed": true}
{"task_id": "OOP/8", "completion": "class TSN:\n    def __init__(self, routes):\n        self.routes = routes\n\nclass SN_TSN(TSN):\n    def __init__(self, routes, source, target):\n        super().__init__(routes)\n        self.source = source\n        self.target = target\n\n    def Terminal_Station(self):\n        if self.source == self.target:\n            return 0\n\n        from collections import defaultdict, deque\n        \n        stop_to_buses = defaultdict(list)\n        for bus_index, route in enumerate(self.routes):\n            for stop in route:\n                stop_to_buses[stop].append(bus_index)\n\n        queue = deque([self.source])\n        visited_stops = set([self.source])\n        visited_buses = set()\n        buses_count = 0\n\n        while queue:\n            buses_count += 1\n            for _ in range(len(queue)):\n                current_stop = queue.popleft()\n                for bus_index in stop_to_buses[current_stop]:\n                    if bus_index in visited_buses:\n                        continue\n                    visited_buses.add(bus_index)\n                    for stop in self.routes[bus_index]:\n                        if stop == self.target:\n                            return buses_count\n                        if stop not in visited_stops:\n                            visited_stops.add(stop)\n                            queue.append(stop)\n\n        return -1", "result": "passed", "passed": true}
{"task_id": "OOP/9", "completion": "class AOR:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_AOR(AOR):\n    def Any_order(self):\n        results = []\n        n = len(self.s)\n\n        # Helper function to generate valid coordinates\n        def generate_coordinates(start):\n            for i in range(start + 1, n + 1):\n                # First part (X coordinate)\n                x_str = self.s[start:i]\n                if not self.is_valid_number(x_str):\n                    continue\n                \n                for j in range(i + 1, n + 1):\n                    # Second part (Y coordinate)\n                    y_str = self.s[i:j]\n                    if not self.is_valid_number(y_str):\n                        continue\n                    \n                    original_string = f\"{x_str} {y_str}\"\n                    results.append(original_string)\n\n        for i in range(1, n):  # We need at least one digit for X\n            generate_coordinates(0)\n\n        return results\n\n    def is_valid_number(self, num_str):\n        if not num_str or (num_str == \"0\" and len(num_str) > 1):\n            return False\n        if '.' in num_str:\n            parts = num_str.split('.')\n            if len(parts) != 2 or not parts[0] or not parts[1]:\n                return False\n            if parts[0] == \"0\" and len(parts[0]) > 1:  # No leading zeros\n                return False\n        return True", "result": "failed: ", "passed": false}
{"task_id": "OOP/10", "completion": "class ECG:\n    def __init__(self, words):\n        self.words = words\n\n\nclass SN_ECG(ECG):\n    def efficient_coding(self):\n        total_length = 0\n        for word in self.words:\n            total_length += len(word) + 1  # +1 for the '#' character\n        return total_length + 1  # +1 for the final '#' at the end of the string", "result": "failed: ", "passed": false}
{"task_id": "OOP/11", "completion": "class CDC:\n    def __init__(self, s):\n        self.s = s\n\n\nclass SN_CDC(CDC):\n    def __init__(self, s, c):\n        super().__init__(s)\n        self.c = c\n\n    def Character_distance(self):\n        answer = [0] * len(self.s)\n        last_c = float('-inf')\n\n        # Forward pass\n        for i in range(len(self.s)):\n            if self.s[i] == self.c:\n                last_c = i\n            answer[i] = i - last_c\n\n        last_c = float('inf')\n\n        # Backward pass\n        for i in range(len(self.s)-1, -1, -1):\n            if self.s[i] == self.c:\n                last_c = i\n            answer[i] = min(answer[i], last_c - i)\n\n        return answer", "result": "passed", "passed": true}
{"task_id": "OOP/12", "completion": "class RIR:\n    def __init__(self, arr):\n        self.arr = arr\n\n\nclass SN_RIR(RIR):\n    def repeating_integer(self):\n        if not self.arr:\n            return 0\n        \n        count_map = {}\n        \n        def count_trees(arr):\n            if len(arr) == 1:\n                return 1\n            \n            count = 0\n            for i in range(len(arr)):\n                left = arr[i]\n                right_options = arr[:i] + arr[i+1:]\n                for right in right_options:\n                    product = left * right\n                    if product in count_map:\n                        count += count_map[product]\n                    else:\n                        count_map[product] = count_trees(right_options)\n                        count += count_map[product]\n\n            return count\n        \n        return count_trees(self.arr)", "result": "failed: ", "passed": false}
{"task_id": "OOP/13", "completion": "class MPT:\n    def __init__(self, difficulty):\n        self.difficulty = difficulty\n\nclass SN_MPT(MPT):\n    def __init__(self, difficulty, profit, worker):\n        super().__init__(difficulty)\n        self.profit = profit\n        self.worker = worker\n\n    def Maximum_profit(self):\n        max_profit = 0\n        jobs = sorted(zip(self.difficulty, self.profit), key=lambda x: x[0])\n        self.worker.sort()\n        \n        max_job_profit = 0\n        job_index = 0\n        jobs_length = len(jobs)\n\n        for ability in self.worker:\n            while job_index < jobs_length and jobs[job_index][0] <= ability:\n                max_job_profit = max(max_job_profit, jobs[job_index][1])\n                job_index += 1\n            max_profit += max_job_profit\n        \n        return max_profit", "result": "passed", "passed": true}
{"task_id": "OOP/14", "completion": "class IAA:\n    def __init__(self, grid):\n        self.grid = grid\n\nclass SN_IAA(IAA):\n    def Island_area(self):\n        n = len(self.grid)\n        visited = [[False] * n for _ in range(n)]\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        def dfs(x, y):\n            stack = [(x, y)]\n            area = 0\n            while stack:\n                cx, cy = stack.pop()\n                if visited[cx][cy]:\n                    continue\n                visited[cx][cy] = True\n                area += 1\n                for dx, dy in directions:\n                    nx, ny = cx + dx, cy + dy\n                    if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and self.grid[nx][ny] == 1:\n                        stack.append((nx, ny))\n            return area\n        \n        max_area = 0\n        island_areas = []\n        \n        # Calculate areas of existing islands\n        for i in range(n):\n            for j in range(n):\n                if self.grid[i][j] == 1 and not visited[i][j]:\n                    area = dfs(i, j)\n                    island_areas.append(area)\n                    max_area = max(max_area, area)\n        \n        # Try changing each 0 to 1 and check new island area\n        for i in range(n):\n            for j in range(n):\n                if self.grid[i][j] == 0:\n                    new_area = 1  # account for the newly changed 1\n                    neighbor_areas = set()\n                    for dx, dy in directions:\n                        nx, ny = i + dx, j + dy\n                        if 0 <= nx < n and 0 <= ny < n and self.grid[nx][ny] == 1:\n                            neighbor_index = visited[nx][ny]\n                            if neighbor_index not in neighbor_areas:\n                                neighbor_areas.add(neighbor_index)\n                                new_area += island_areas[neighbor_index]\n                    max_area = max(max_area, new_area)\n        \n        return max_area", "result": "failed: ", "passed": false}
{"task_id": "OOP/15", "completion": "class UCR:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_UCR(UCR):\n    def Unique_character(self):\n        return len(set(self.s))", "result": "failed: ", "passed": false}
{"task_id": "OOP/16", "completion": "class SNS:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_SNS(SNS):\n    def Sum_Numbers(self):\n        count = 0\n        for length in range(1, self.n + 1):\n            if (self.n - (length * (length - 1) // 2)) > 0 and (self.n - (length * (length - 1) // 2)) % length == 0:\n                count += 1\n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/17", "completion": "class SDC:\n    def __init__(self, n):\n        self.n = n\n\n\nclass SN_SDC(SDC):\n    def __init__(self, n, edges):\n        super().__init__(n)\n        self.edges = edges\n    \n    def Sum_distances(self):\n        from collections import defaultdict\n\n        def dfs(node, parent):\n            subtree_size[node] = 1\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    dfs(neighbor, node)\n                    subtree_size[node] += subtree_size[neighbor]\n                    distance_sum[node] += distance_sum[neighbor] + subtree_size[neighbor]\n\n        def dfs2(node, parent):\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    distance_sum[neighbor] = distance_sum[node] - subtree_size[neighbor] + (self.n - subtree_size[neighbor])\n                    dfs2(neighbor, node)\n\n        graph = defaultdict(list)\n        for a, b in self.edges:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        subtree_size = [0] * self.n\n        distance_sum = [0] * self.n\n\n        dfs(0, -1)\n        dfs2(0, -1)\n\n        return distance_sum", "result": "passed", "passed": true}
{"task_id": "OOP/18", "completion": "class OQT:\n    def __init__(self, img1):\n        self.img1 = img1\n\nclass SN_OQT(OQT):\n    def __init__(self, img1, img2):\n        super().__init__(img1)\n        self.img2 = img2\n\n    def Overlap_quantity(self):\n        def get_overlap(x_offset, y_offset):\n            overlap = 0\n            for i in range(len(self.img1)):\n                for j in range(len(self.img1)):\n                    if (0 <= i + x_offset < len(self.img1) and\n                        0 <= j + y_offset < len(self.img1)):\n                        overlap += self.img1[i][j] * self.img2[i + x_offset][j + y_offset]\n            return overlap\n\n        n = len(self.img1)\n        max_overlap = 0\n\n        for x_offset in range(-n + 1, n):\n            for y_offset in range(-n + 1, n):\n                max_overlap = max(max_overlap, get_overlap(x_offset, y_offset))\n\n        return max_overlap", "result": "passed", "passed": true}
{"task_id": "OOP/19", "completion": "class ROP:\n    def __init__(self, rec1):\n        self.rec1 = rec1\n\nclass SN_ROP(ROP):\n    def __init__(self, rec1, rec2):\n        super().__init__(rec1)\n        self.rec2 = rec2\n\n    def Rectangle_overlap(self):\n        x1_rec1, y1_rec1, x2_rec1, y2_rec1 = self.rec1\n        x1_rec2, y1_rec2, x2_rec2, y2_rec2 = self.rec2\n\n        # Check if there is overlap\n        overlap = not (x2_rec1 <= x1_rec2 or x2_rec2 <= x1_rec1 or y2_rec1 <= y1_rec2 or y2_rec2 <= y1_rec1)\n        return overlap", "result": "passed", "passed": true}
{"task_id": "OOP/20", "completion": "class ENS:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_ENS(ENS):\n    def __init__(self, n, k, maxPts):\n        super().__init__(n)\n        self.k = k\n        self.maxPts = maxPts\n\n    def Extract_Numbers(self):\n        dp = [0] * (self.n + 1)\n        dp[0] = 1  # There is one way to have a score of 0\n        \n        for score in range(1, self.n + 1):\n            for draw in range(1, self.maxPts + 1):\n                if score - draw >= 0:\n                    dp[score] += dp[score - draw]\n        \n        total_ways = sum(dp[max(0, score - self.k) : self.n + 1])\n        return total_ways / (self.maxPts ** (self.n // self.k)) if self.n >= self.k else total_ways / (self.maxPts ** self.n)", "result": "failed: ", "passed": false}
{"task_id": "OOP/21", "completion": "class SST:\n    def __init__(self, strs):\n        self.strs = strs\n\nclass SN_SST(SST):\n    def Similar_Strings(self):\n        def are_similar(s1, s2):\n            if s1 == s2:\n                return True\n            diff = [(a, b) for a, b in zip(s1, s2) if a != b]\n            return len(diff) == 2 and diff[0][0] == diff[1][1] and diff[0][1] == diff[1][0]\n\n        visited = [False] * len(self.strs)\n        count = 0\n\n        for i in range(len(self.strs)):\n            if not visited[i]:\n                count += 1\n                for j in range(len(self.strs)):\n                    if not visited[j] and are_similar(self.strs[i], self.strs[j]):\n                        visited[j] = True\n\n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/22", "completion": "class SAX:\n    def __init__(self, grid):\n        self.grid = grid\n\n\nclass SN_SAX(SAX):\n    def submatrix(self):\n        magic_squares = set([\n            (8, 1, 6, 3, 5, 7, 4, 9, 2),\n            (6, 1, 8, 7, 5, 3, 2, 9, 4),\n        ])\n        \n        count = 0\n        \n        for i in range(len(self.grid) - 2):\n            for j in range(len(self.grid[0]) - 2):\n                sub = (self.grid[i][j], self.grid[i][j+1], self.grid[i][j+2],\n                       self.grid[i+1][j], self.grid[i+1][j+1], self.grid[i+1][j+2],\n                       self.grid[i+2][j], self.grid[i+2][j+1], self.grid[i+2][j+2])\n                \n                if sub in magic_squares:\n                    count += 1\n                    \n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/23", "completion": "class ARS:\n    def __init__(self, rooms):\n        self.rooms = rooms\n\n\nclass SN_ARS(ARS):\n    def All_rooms(self):\n        n = len(self.rooms)\n        visited = set()\n        stack = [0]\n        \n        while stack:\n            room = stack.pop()\n            if room not in visited:\n                visited.add(room)\n                for key in self.rooms[room]:\n                    if key not in visited:\n                        stack.append(key)\n        \n        return len(visited) == n", "result": "failed: ", "passed": false}
{"task_id": "OOP/24", "completion": "class FEQ:\n    def __init__(self, num: str):\n        self.num = num\n\n\nclass SN_FEQ(FEQ):\n    def Fibonacci_equation(self):\n        n = len(self.num)\n\n        def is_valid_chunk(chunk):\n            return chunk == \"0\" or chunk[0] != \"0\"\n\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                first = self.num[:i]\n                second = self.num[i:j]\n                if not (is_valid_chunk(first) and is_valid_chunk(second)):\n                    continue\n\n                fib_sequence = [int(first), int(second)]\n                start_index = j\n\n                while start_index < n:\n                    next_fib = fib_sequence[-1] + fib_sequence[-2]\n                    next_fib_str = str(next_fib)\n                    \n                    if not self.num.startswith(next_fib_str, start_index):\n                        break\n                    \n                    fib_sequence.append(next_fib)\n                    start_index += len(next_fib_str)\n\n                if start_index == n and len(fib_sequence) >= 3:\n                    return fib_sequence\n\n        return []", "result": "failed: ", "passed": false}
{"task_id": "OOP/25", "completion": "class LMN:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_LMN(LMN):\n    def Longest_mountain(self):\n        n = len(self.arr)\n        if n < 3:\n            return 0\n        \n        longest = 0\n        for i in range(1, n - 1):\n            if self.arr[i - 1] < self.arr[i] > self.arr[i + 1]:\n                left = i - 1\n                right = i + 1\n                \n                while left > 0 and self.arr[left - 1] < self.arr[left]:\n                    left -= 1\n                \n                while right < n - 1 and self.arr[right] > self.arr[right + 1]:\n                    right += 1\n                \n                longest = max(longest, right - left + 1)\n        \n        return longest if longest >= 3 else 0", "result": "failed: ", "passed": false}
{"task_id": "OOP/26", "completion": "class RRG:\n    def __init__(self, hand):\n        self.hand = hand\n\nclass SN_RRG(RRG):\n    def __init__(self, hand, groupSize):\n        super().__init__(hand)\n        self.groupSize = groupSize\n\n    def rearrange(self):\n        from collections import Counter\n        \n        if len(self.hand) % self.groupSize != 0:\n            return False\n\n        count = Counter(self.hand)\n        unique_cards = sorted(count.keys())\n\n        for card in unique_cards:\n            while count[card] > 0:\n                for i in range(self.groupSize):\n                    if count[card + i] <= 0:\n                        return False\n                    count[card + i] -= 1\n\n        return True", "result": "passed", "passed": true}
{"task_id": "OOP/27", "completion": "class TTH:\n    def __init__(self, graph):\n        self.graph = graph\n\nclass SN_TTH(TTH):\n    def The_length(self):\n        from collections import deque\n        \n        n = len(self.graph)\n        visited = (1 << n) - 1\n        \n        def bfs(start):\n            queue = deque([(start, 0, 1 << start)])\n            min_length = float('inf')\n            while queue:\n                node, length, visited_mask = queue.popleft()\n                if visited_mask == visited:\n                    min_length = min(min_length, length)\n                for neighbor in self.graph[node]:\n                    next_visited_mask = visited_mask | (1 << neighbor)\n                    queue.append((neighbor, length + 1, next_visited_mask))\n            return min_length\n\n        result = float('inf')\n        for i in range(n):\n            result = min(result, bfs(i))\n\n        return result", "result": "timed out", "passed": false}
{"task_id": "OOP/28", "completion": "class SAN:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_SAN(SAN):\n    def __init__(self, s, shifts):\n        super().__init__(s)\n        self.shifts = shifts\n\n    def Shift_application(self):\n        result = []\n        for i in range(len(self.s)):\n            shift = self.shifts[i]\n            new_char = chr((ord(self.s[i]) - ord('a') + shift) % 26 + ord('a'))\n            result.append(new_char)\n        return ''.join(result)", "result": "failed: ", "passed": false}
{"task_id": "OOP/29", "completion": "class ASG:\n    def __init__(self, seats):\n        self.seats = seats\n\nclass SN_ASG(ASG):\n    def Maximized_seating(self):\n        max_distance = 0\n        prev_person = -1\n        n = len(self.seats)\n\n        for i in range(n):\n            if self.seats[i] == 1:\n                if prev_person == -1:  # First person\n                    max_distance = i\n                else:\n                    distance = (i - prev_person) // 2\n                    max_distance = max(max_distance, distance)\n                prev_person = i\n\n        # Check the distance to the right end\n        max_distance = max(max_distance, n - 1 - prev_person)\n\n        return max_distance", "result": "failed: ", "passed": false}
{"task_id": "OOP/30", "completion": "class TAR:\n    def __init__(self, rectangles):\n        self.rectangles = rectangles\n\n\nclass SN_TAR(TAR):\n    def total_area(self):\n        events = []\n        for x1, y1, x2, y2 in self.rectangles:\n            events.append((x1, y1, y2, 1))  # starting edge\n            events.append((x2, y1, y2, -1))  # ending edge\n\n        events.sort()  # sort by x-coordinate\n\n        def calculate_y_length(active_intervals):\n            active_intervals.sort()\n            length = 0\n            current_start = -1\n            for start, end in active_intervals:\n                if start > current_start:\n                    length += end - start\n                    current_start = end\n                elif end > current_start:\n                    length += end - current_start\n                    current_start = end\n            return length\n\n        last_x = events[0][0]\n        area = 0\n        active_intervals = []\n\n        for x, y1, y2, typ in events:\n            area += (x - last_x) * calculate_y_length(active_intervals)\n            if typ == 1:  # starting edge\n                active_intervals.append((y1, y2))\n            else:  # ending edge\n                active_intervals.remove((y1, y2))\n            last_x = x\n\n        return area", "result": "failed: ", "passed": false}
{"task_id": "OOP/31", "completion": "class MVE:\n    def __init__(self, s1):\n        self.s1 = s1\n\nclass SN_MVE(MVE):\n    def __init__(self, s1, s2):\n        super().__init__(s1)\n        self.s2 = s2\n\n    def Minimum_value(self):\n        count = 0\n        s1_list = list(self.s1)\n        s2_list = list(self.s2)\n\n        for i in range(len(s1_list)):\n            if s1_list[i] != s2_list[i]:\n                count += 1\n\n        return count // 2  # Each swap fixes two positions", "result": "failed: ", "passed": false}
{"task_id": "OOP/32", "completion": "class BPS:\n    def __init__(self, S):\n        self.S = S\n\nclass SN_BPS(BPS):\n    def Balanced_parentheses(self):\n        def score(s):\n            stack = []\n            for char in s:\n                if char == '(':\n                    stack.append(char)\n                else:\n                    temp_score = 0\n                    while stack and stack[-1] != '(':\n                        temp_score += stack.pop()\n                    stack.pop()  # pop the '('\n                    if temp_score == 0:\n                        stack.append(1)  # () -> 1\n                    else:\n                        stack.append(2 * temp_score)  # (A) -> 2*A\n            return sum(stack)  # sum up all the scores in the stack\n\n        return score(self.S)", "result": "failed: ", "passed": false}
{"task_id": "OOP/33", "completion": "class RNE:\n    def __init__(self, p):\n        self.p = p\n\nclass SN_RNE(RNE):\n    def __init__(self, p, q):\n        super().__init__(p)\n        self.q = q\n\n    def Receiver_number(self):\n        if self.q % (2 * self.p) < self.p:\n            return 1  # East wall\n        else:\n            return 2  # North wall", "result": "failed: ", "passed": false}
{"task_id": "OOP/34", "completion": "class HSE:\n    def __init__(self, grid):\n        self.grid = grid\n\nclass SN_HSE(HSE):\n    def Highest_Score(self):\n        m, n = len(self.grid), len(self.grid[0])\n        max_score = 0\n        \n        for j in range(n):\n            column_one_count = sum(self.grid[i][j] for i in range(m))\n            if column_one_count < m / 2:\n                for i in range(m):\n                    self.grid[i][j] ^= 1  # Flip the column\n        \n        for row in self.grid:\n            row_score = sum(val * (1 << (len(row) - 1 - idx)) for idx, val in enumerate(row))\n            max_score += row_score\n        \n        return max_score", "result": "failed: ", "passed": false}
{"task_id": "OOP/35", "completion": "class SEY:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_SEY(SEY):\n    def __init__(self, nums, k):\n        super().__init__(nums)\n        self.k = k\n\n    def Shortest_empty(self):\n        n = len(self.nums)\n        res = float('inf')\n        prefix_sum = [0] * (n + 1)\n\n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + self.nums[i - 1]\n\n        from collections import deque\n        deq = deque()\n\n        for i in range(n + 1):\n            while deq and prefix_sum[i] - prefix_sum[deq[0]] >= self.k:\n                res = min(res, i - deq.popleft())\n            while deq and prefix_sum[i] <= prefix_sum[deq[-1]]:\n                deq.pop()\n            deq.append(i)\n\n        return res if res != float('inf') else -1", "result": "passed", "passed": true}
{"task_id": "OOP/36", "completion": "class PPM:\n    def __init__(self, N):\n        self.N = N\n\nclass SN_PPM(PPM):\n    def is_prime(self, num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_palindrome(self, num):\n        return str(num) == str(num)[::-1]\n\n    def prime_palindromes(self):\n        num = self.N\n        while True:\n            if self.is_palindrome(num) and self.is_prime(num):\n                return num\n            num += 1", "result": "failed: ", "passed": false}
{"task_id": "OOP/37", "completion": "class NRG:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_NRG(NRG):\n    def Number_Reordering(self):\n        from itertools import permutations\n        \n        digits = str(self.n)\n        powers_of_2 = {str(2**i) for i in range(31)}  # Up to 2^30\n        \n        for perm in permutations(digits):\n            if perm[0] != '0':  # leading digit cannot be zero\n                if ''.join(perm) in powers_of_2:\n                    return True\n        return False", "result": "failed: ", "passed": false}
{"task_id": "OOP/38", "completion": "class MAS:\n    def __init__(self, nums1):\n        self.nums1 = sorted(nums1)\n\nclass SN_MAS(MAS):\n    def __init__(self, nums1, nums2):\n        super().__init__(nums1)\n        self.nums2 = nums2\n\n    def Maximizing_Advantages(self):\n        from collections import deque\n        nums1_deque = deque(self.nums1)\n        nums2_indices = sorted(range(len(self.nums2)), key=lambda x: self.nums2[x])\n        result = [-1] * len(self.nums2)\n        \n        for index in nums2_indices:\n            if nums1_deque and nums1_deque[-1] > self.nums2[index]:\n                result[index] = nums1_deque.pop()\n            else:\n                result[index] = nums1_deque.popleft()\n        \n        return result", "result": "failed: ", "passed": false}
{"task_id": "OOP/39", "completion": "class PAY:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_PAY(PAY):\n    def Positive_array(self):\n        n = len(self.arr)\n        if n < 3:\n            return 0\n        \n        index = {num: i for i, num in enumerate(self.arr)}\n        max_length = 0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                x, y = self.arr[i], self.arr[j]\n                length = 2\n                \n                while x + y in index:\n                    length += 1\n                    x, y = y, x + y\n                \n                max_length = max(max_length, length)\n        \n        return max_length if max_length >= 3 else 0", "result": "failed: ", "passed": false}
{"task_id": "OOP/40", "completion": "class MSD:\n    def __init__(self, piles):\n        self.piles = piles\n\nclass SN_MSD(MSD):\n    def __init__(self, piles, h):\n        super().__init__(piles)\n        self.h = h\n\n    def Minimum_Speed(self):\n        def can_finish(k):\n            hours_needed = 0\n            for pile in self.piles:\n                hours_needed += (pile + k - 1) // k\n            return hours_needed <= self.h\n        \n        left, right = 1, max(self.piles)\n        while left < right:\n            mid = (left + right) // 2\n            if can_finish(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "result": "passed", "passed": true}
{"task_id": "OOP/41", "completion": "class MNS:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_MNS(MNS):\n    def __init__(self, n, a, b):\n        super().__init__(n)\n        self.a = a\n        self.b = b\n\n    def Magical_Numbers(self):\n        count = 0\n        num = 0\n        while count < self.n:\n            num += 1\n            if num % self.a == 0 or num % self.b == 0:\n                count += 1\n        return num", "result": "passed", "passed": true}
{"task_id": "OOP/42", "completion": "class PPN:\n    def __init__(self, n):\n        self.n = n\n\n\nclass SN_PPN(PPN):\n    def __init__(self, n, minProfit, group, profit):\n        super().__init__(n)\n        self.minProfit = minProfit\n        self.group = group\n        self.profit = profit\n\n    def Profit_Plan(self):\n        from itertools import combinations\n\n        total_plans = 0\n        jobs_count = len(self.group)\n\n        for r in range(jobs_count + 1):\n            for job_subset in combinations(range(jobs_count), r):\n                total_members = sum(self.group[i] for i in job_subset)\n                total_profit = sum(self.profit[i] for i in job_subset)\n\n                if total_members <= self.n and total_profit >= self.minProfit:\n                    total_plans += 1\n\n        return total_plans", "result": "passed", "passed": true}
{"task_id": "OOP/43", "completion": "class DSG:\n    def __init__(self, S):\n        self.S = S\n\nclass SN_DSG(DSG):\n    def __init__(self, S, K):\n        super().__init__(S)\n        self.K = K\n\n    def Decode_String(self):\n        stack = []\n        current_string = \"\"\n        for char in self.S:\n            if char.isalpha():\n                current_string += char\n            elif char.isdigit():\n                if current_string:\n                    stack.append(current_string)\n                current_string = \"\"\n                count = int(char)\n                if stack:\n                    current_string = stack.pop() * (count - 1) + current_string\n        if current_string:\n            stack.append(current_string)\n        \n        decoded_string = ''.join(stack)\n        return decoded_string[self.K - 1] if 0 <= self.K - 1 < len(decoded_string) else ''", "result": "failed: ", "passed": false}
{"task_id": "OOP/44", "completion": "class MSS:\n    def __init__(self, people):\n        self.people = people\n\nclass SN_MSS(MSS):\n    def __init__(self, people, limit):\n        super().__init__(people)\n        self.limit = limit\n\n    def Minimum_ships(self):\n        self.people.sort()\n        left, right = 0, len(self.people) - 1\n        boats = 0\n        \n        while left <= right:\n            if self.people[left] + self.people[right] <= self.limit:\n                left += 1\n            right -= 1\n            boats += 1\n            \n        return boats", "result": "passed", "passed": true}
{"task_id": "OOP/45", "completion": "class TPD:\n    def __init__(self, grid):\n        self.grid = grid\n\nclass SN_TPD(TPD):\n    def Total_projected(self):\n        n = len(self.grid)\n        \n        xy_projection = n * n  # All cells contribute to xy projection\n        yz_projection = sum(1 for j in range(n) for i in range(n) if self.grid[i][j] > 0)  # Count non-zero columns for yz projection\n        zx_projection = sum(max(row) for row in self.grid)  # Max height in each row for zx projection\n\n        total_area = xy_projection + yz_projection + zx_projection\n        return total_area", "result": "failed: ", "passed": false}
{"task_id": "OOP/46", "completion": "class CLT:\n    def __init__(self, rows):\n        self.rows = rows\n\nclass SN_CLT(CLT):\n    def __init__(self, rows, cols, rStart, cStart):\n        super().__init__(rows)\n        self.cols = cols\n        self.rStart = rStart\n        self.cStart = cStart\n\n    def Coordinate_List(self):\n        result = []\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # east, south, west, north\n        direction_index = 0\n        row, col = self.rStart, self.cStart\n        visited = set()\n\n        for _ in range(self.rows * self.cols):\n            result.append((row, col))\n            visited.add((row, col))\n\n            # Calculate the next position\n            next_row = row + directions[direction_index][0]\n            next_col = col + directions[direction_index][1]\n\n            # Check if the next position is within bounds and not visited\n            if (0 <= next_row < self.rows and 0 <= next_col < self.cols and\n                    (next_row, next_col) not in visited):\n                row, col = next_row, next_col\n            else:\n                # Change direction\n                direction_index = (direction_index + 1) % 4\n                row += directions[direction_index][0]\n                col += directions[direction_index][1]\n\n        return result", "result": "failed: ", "passed": false}
{"task_id": "OOP/47", "completion": "class GPG:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_GPG(GPG):\n    def __init__(self, n, dislikes):\n        super().__init__(n)\n        self.dislikes = dislikes\n\n    def grouping(self):\n        graph = {i: [] for i in range(1, self.n + 1)}\n        for a, b in self.dislikes:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        color = {}\n\n        def dfs(node, c):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(neighbor, c ^ 1) for neighbor in graph[node])\n\n        for person in range(1, self.n + 1):\n            if person not in color and not dfs(person, 0):\n                return False\n\n        return True", "result": "passed", "passed": true}
{"task_id": "OOP/48", "completion": "class NOS:\n    def __init__(self, k):\n        self.k = k\n\nclass SN_NOS(NOS):\n    def __init__(self, k, n):\n        super().__init__(k)\n        self.n = n\n\n    def number_operations(self):\n        dp = [[0] * (self.n + 1) for _ in range(self.k + 1)]\n        \n        for i in range(1, self.k + 1):\n            for j in range(1, self.n + 1):\n                if i == 1:\n                    dp[i][j] = j\n                else:\n                    dp[i][j] = float('inf')\n                    for x in range(1, j + 1):\n                        res = 1 + max(dp[i - 1][x - 1], dp[i][j - x])\n                        dp[i][j] = min(dp[i][j], res)\n        \n        return dp[self.k][self.n]", "result": "passed", "passed": true}
{"task_id": "OOP/49", "completion": "class SWS:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_SWS(SWS):\n    def Sum_widths(self):\n        total_width = 0\n        n = len(self.nums)\n        self.nums.sort()\n        \n        for i in range(n):\n            max_count = 1 << i\n            min_count = 1 << (n - i - 1)\n            total_width += (self.nums[i] * max_count - self.nums[i] * min_count)\n        \n        return total_width", "result": "failed: ", "passed": false}
{"task_id": "OOP/50", "completion": "class FAR:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_FAR(FAR):\n    def Final_Answer(self):\n        results = set()\n        n = len(self.arr)\n        for i in range(n):\n            current_or = 0\n            for j in range(i, n):\n                current_or |= self.arr[j]\n                results.add(current_or)\n        return len(results)", "result": "failed: ", "passed": false}
{"task_id": "OOP/51", "completion": "class SSG:\n    def __init__(self, s: str):\n        self.s = s\n\nclass SN_SSG(SSG):\n    def __init__(self, s: str, k: int):\n        super().__init__(s)\n        self.k = k\n\n    def Smallest_string(self) -> str:\n        smallest = self.s\n        for i in range(min(self.k, len(self.s))):\n            new_string = self.s[i:] + self.s[:i]\n            if new_string < smallest:\n                smallest = new_string\n        return smallest", "result": "failed: ", "passed": false}
{"task_id": "OOP/52", "completion": "class NDG:\n    def __init__(self, digits):\n        self.digits = sorted(set(digits))\n\nclass SN_NDG(NDG):\n    def __init__(self, digits, n):\n        super().__init__(digits)\n        self.n = n\n\n    def Non_decreasing(self):\n        count = 0\n        m = len(self.digits)\n        n_str = str(self.n)\n        length = len(n_str)\n\n        for i in range(1, length):\n            count += m ** i\n\n        def count_less_than_last_digit(idx, prev_digit):\n            if idx == length:\n                return 1\n            total = 0\n            for digit in self.digits:\n                if digit < prev_digit:\n                    total += count_less_than_last_digit(idx + 1, digit)\n                elif digit == prev_digit:\n                    total += count_less_than_last_digit(idx + 1, digit)\n                    break\n            return total\n\n        count += count_less_than_last_digit(0, '9')\n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/53", "completion": "class EAT:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_EAT(EAT):\n    def Effective_arrangement(self):\n        n = len(self.s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] * (n + 1 - i)\n            if self.s[i - 1] == 'D':\n                for j in range(i):\n                    dp[j] = dp[j + 1]\n            else:\n                for j in range(i - 1, -1, -1):\n                    dp[j + 1] = dp[j]\n        \n        return dp[0]", "result": "failed: ", "passed": false}
{"task_id": "OOP/54", "completion": "class IAY:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_IAY(IAY):\n    def Integer_array(self):\n        total_sum = 0\n        n = len(self.arr)\n        \n        for i in range(n):\n            min_element = self.arr[i]\n            for j in range(i, n):\n                min_element = min(min_element, self.arr[j])\n                total_sum += min_element\n        \n        return total_sum", "result": "failed: ", "passed": false}
{"task_id": "OOP/55", "completion": "class MSE:\n    def __init__(self, nums):\n        self.nums = nums\n\n\nclass SN_MSE(MSE):\n    def __init__(self, nums, k):\n        super().__init__(nums)\n        self.k = k\n\n    def Minimum_score(self):\n        max_num = max(self.nums)\n        min_num = min(self.nums)\n        return max(0, (max_num - self.k) - (min_num + self.k))", "result": "failed: ", "passed": false}
{"task_id": "OOP/56", "completion": "class AOR:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_AOR(AOR):\n    def ascend_order(self):\n        self.nums.sort()", "result": "failed: ", "passed": false}
{"task_id": "OOP/57", "completion": "class CGS:\n    def __init__(self, graph):\n        self.graph = graph\n\n\nclass SN_CGS(CGS):\n    def Cat_games(self):\n        from collections import deque\n        \n        mouse_start = 1\n        cat_start = 2\n        hole = 0\n        visited = set()\n        \n        queue = deque([(mouse_start, cat_start, 0)])  # (mouse_position, cat_position, turn)\n        \n        while queue:\n            mouse_pos, cat_pos, turn = queue.popleft()\n            \n            if (mouse_pos, cat_pos, turn) in visited:\n                continue\n            visited.add((mouse_pos, cat_pos, turn))\n            \n            if mouse_pos == cat_pos:\n                return 2  # Cat wins\n            if mouse_pos == hole:\n                return 1  # Mouse wins\n            \n            if turn % 2 == 0:  # Mouse's turn\n                for next_mouse_pos in self.graph[mouse_pos]:\n                    queue.append((next_mouse_pos, cat_pos, turn + 1))\n            else:  # Cat's turn\n                for next_cat_pos in self.graph[cat_pos]:\n                    if next_cat_pos != hole:  # Cat cannot move into the hole\n                        queue.append((mouse_pos, next_cat_pos, turn + 1))\n        \n        return 0  # Draw", "result": "failed: ", "passed": false}
{"task_id": "OOP/58", "completion": "class SIR:\n    def __init__(self, deck):\n        self.deck = deck\n\nclass SN_SIR(SIR):\n    def Same_integer(self):\n        from collections import Counter\n        counts = Counter(self.deck)\n        for card_count in counts.values():\n            if card_count >= 2:\n                return True\n        return False", "result": "failed: ", "passed": false}
{"task_id": "OOP/59", "completion": "class PLH:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_PLH(PLH):\n    def Packet_Length(self):\n        n = len(self.nums)\n        if n < 2:\n            return 0\n        \n        max_left = [0] * n\n        min_right = [0] * n\n        \n        max_left[0] = self.nums[0]\n        for i in range(1, n):\n            max_left[i] = max(max_left[i-1], self.nums[i])\n        \n        min_right[n-1] = self.nums[n-1]\n        for i in range(n-2, -1, -1):\n            min_right[i] = min(min_right[i+1], self.nums[i])\n        \n        for i in range(n - 1):\n            if max_left[i] <= min_right[i + 1]:\n                return i + 1\n        \n        return n - 1  # In case of no valid split, return max left length", "result": "failed: ", "passed": false}
{"task_id": "OOP/60", "completion": "class CWS:\n    def __init__(self, words1):\n        self.words1 = words1\n\nclass SN_CWS(CWS):\n    def __init__(self, words1, words2):\n        super().__init__(words1)\n        self.words2 = words2\n\n    def Common_Words(self):\n        def is_subset(a, b):\n            from collections import Counter\n            count_a = Counter(a)\n            count_b = Counter(b)\n            for char in count_b:\n                if count_b[char] > count_a.get(char, 0):\n                    return False\n            return True\n        \n        universal_words = []\n        for word in self.words1:\n            if all(is_subset(word, b) for b in self.words2):\n                universal_words.append(word)\n        return universal_words", "result": "passed", "passed": true}
{"task_id": "OOP/61", "completion": "class CAY:\n    def __init__(self, nums):\n        self.nums = nums\n\n\nclass SN_CAY(CAY):\n    def Circular_array(self):\n        n = len(self.nums)\n        total_sum = sum(self.nums)\n        max_end_here = max_so_far = self.nums[0]\n        min_end_here = min_so_far = self.nums[0]\n\n        for i in range(1, n):\n            max_end_here = max(self.nums[i], max_end_here + self.nums[i])\n            max_so_far = max(max_so_far, max_end_here)\n\n            min_end_here = min(self.nums[i], min_end_here + self.nums[i])\n            min_so_far = min(min_so_far, min_end_here)\n\n        if max_so_far > 0:\n            return max(max_so_far, total_sum - min_so_far)\n        else:\n            return max_so_far", "result": "failed: ", "passed": false}
{"task_id": "OOP/62", "completion": "class PAL:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_PAL(PAL):\n    def __init__(self, n, goal, k):\n        super().__init__(n)\n        self.goal = goal\n        self.k = k\n\n    def PlayList(self):\n        if self.goal < self.n:\n            return 0\n        \n        dp = [[0] * (self.goal + 1) for _ in range(self.n + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, self.n + 1):\n            for j in range(1, self.goal + 1):\n                dp[i][j] = dp[i - 1][j - 1] * (self.n - i + 1)\n                if i > self.k:\n                    dp[i][j] += dp[i][j - 1] * (i - self.k)\n        \n        return dp[self.n][self.goal]", "result": "passed", "passed": true}
{"task_id": "OOP/63", "completion": "class MPS:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_MPS(MPS):\n    def Minimum_parentheses(self):\n        left_needed = 0\n        right_needed = 0\n        \n        for char in self.s:\n            if char == '(':\n                left_needed += 1\n            elif char == ')':\n                if left_needed > 0:\n                    left_needed -= 1\n                else:\n                    right_needed += 1\n        \n        return left_needed + right_needed", "result": "failed: ", "passed": false}
{"task_id": "OOP/64", "completion": "class ASG:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_ASG(ASG):\n    def Array_sorting(self):\n        evens = [num for num in self.nums if num % 2 == 0]\n        odds = [num for num in self.nums if num % 2 != 0]\n        result = [0] * len(self.nums)\n        \n        result[::2] = evens\n        result[1::2] = odds\n        \n        return result", "result": "failed: ", "passed": false}
{"task_id": "OOP/65", "completion": "class NTS:\n    def __init__(self, arr):\n        self.arr = arr\n\n\nclass SN_NTS(NTS):\n    def __init__(self, arr, target):\n        super().__init__(arr)\n        self.target = target\n\n    def Number_tuples(self):\n        count = 0\n        n = len(self.arr)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    if self.arr[i] + self.arr[j] + self.arr[k] == self.target:\n                        count += 1\n        return count", "result": "passed", "passed": true}
{"task_id": "OOP/66", "completion": "class FTM:\n    def __init__(self, s: str):\n        self.s = s\n\nclass SN_FTM(FTM):\n    def Flip_Times(self) -> int:\n        count_0 = 0\n        count_1 = 0\n        \n        for char in self.s:\n            if char == '0':\n                count_1 += 1\n            else:\n                count_0 += count_0 + 1\n        \n        return min(count_0, count_1)", "result": "failed: ", "passed": false}
{"task_id": "OOP/67", "completion": "class BVE:\n    def __init__(self, arr):\n        self.arr = arr\n\n\nclass SN_BVE(BVE):\n    def Binary_values(self):\n        total_ones = sum(self.arr)\n        if total_ones % 3 != 0:\n            return [-1, -1]\n        if total_ones == 0:\n            return [0, len(self.arr) - 1]\n\n        ones_per_part = total_ones // 3\n        first_split, second_split, third_split = -1, -1, -1\n        ones_count = 0\n\n        for i in range(len(self.arr)):\n            if self.arr[i] == 1:\n                ones_count += 1\n                if ones_count == 1:\n                    first_split = i\n                elif ones_count == ones_per_part + 1:\n                    second_split = i\n                elif ones_count == 2 * ones_per_part + 1:\n                    third_split = i\n\n        while third_split < len(self.arr) and self.arr[first_split] == self.arr[second_split] == self.arr[third_split]:\n            first_split += 1\n            second_split += 1\n            third_split += 1\n\n        if first_split > second_split or second_split > third_split:\n            return [-1, -1]\n\n        return [first_split - 1, second_split]", "result": "failed: ", "passed": false}
{"task_id": "OOP/68", "completion": "class NSY:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_NSY(NSY):\n    def __init__(self, nums, goal):\n        super().__init__(nums)\n        self.goal = goal\n\n    def Non_subarray(self):\n        count = 0\n        prefix_sum = {0: 1}\n        current_sum = 0\n        \n        for num in self.nums:\n            current_sum += num\n            if current_sum - self.goal in prefix_sum:\n                count += prefix_sum[current_sum - self.goal]\n            if current_sum in prefix_sum:\n                prefix_sum[current_sum] += 1\n            else:\n                prefix_sum[current_sum] = 1\n        \n        return count", "result": "passed", "passed": true}
{"task_id": "OOP/69", "completion": "class DPH:\n    def __init__(self, matrix):\n        self.matrix = matrix\n\nclass SN_DPH(DPH):\n    def descent_path(self):\n        n = len(self.matrix)\n        if n == 0:\n            return 0\n\n        # Create a dp array to store the minimum path sums\n        dp = [[float('inf')] * n for _ in range(n)]\n        \n        # Initialize the last row of dp with the last row of the matrix\n        for j in range(n):\n            dp[n-1][j] = self.matrix[n-1][j]\n\n        # Fill the dp array from bottom to top\n        for i in range(n-2, -1, -1):\n            for j in range(n):\n                # Get the minimum path sum from the row below\n                for k in range(max(0, j-1), min(n, j+2)):\n                    dp[i][j] = min(dp[i][j], self.matrix[i][j] + dp[i+1][k])\n        \n        # Return the minimum value from the first row of dp\n        return min(dp[0])", "result": "failed: ", "passed": false}
{"task_id": "OOP/70", "completion": "class BAR:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_BAR(BAR):\n    def Beautiful_array(self):\n        if self.n == 1:\n            return [1]\n\n        beautiful = []\n        odds = [i for i in range(1, self.n + 1) if i % 2 != 0]\n        evens = [i for i in range(1, self.n + 1) if i % 2 == 0]\n        beautiful.extend(odds)\n        beautiful.extend(evens)\n\n        return beautiful", "result": "failed: ", "passed": false}
{"task_id": "OOP/71", "completion": "class FNE:\n    def __init__(self, grid):\n        self.grid = grid\n\nclass SN_FNE(FNE):\n    def __init__(self, grid):\n        super().__init__(grid)\n\n    def flip_number(self):\n        n = len(self.grid)\n        visited = [[False] * n for _ in range(n)]\n        \n        def bfs(start):\n            queue = [start]\n            distance = [[-1] * n for _ in range(n)]\n            distance[start[0]][start[1]] = 0\n            directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n            lands = []\n\n            while queue:\n                x, y = queue.pop(0)\n                lands.append((x, y))\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]:\n                        if self.grid[nx][ny] == 1:\n                            visited[nx][ny] = True\n                            queue.append((nx, ny))\n                        elif self.grid[nx][ny] == 0:\n                            distance[nx][ny] = min(distance[nx][ny] if distance[nx][ny] != -1 else float('inf'), distance[x][y] + 1)\n\n            return lands, distance\n        \n        first_island = None\n        second_island = None\n\n        for i in range(n):\n            for j in range(n):\n                if self.grid[i][j] == 1 and not visited[i][j]:\n                    if first_island is None:\n                        first_island, distance1 = bfs((i, j))\n                    elif second_island is None:\n                        second_island, distance2 = bfs((i, j))\n                        break\n\n        min_flips = float('inf')\n\n        for x1, y1 in first_island:\n            for dx in range(-1, 2):\n                for dy in range(-1, 2):\n                    if abs(dx) != abs(dy):  # Ensure we are stepping in the 4 directions only\n                        nx, ny = x1 + dx, y1 + dy\n                        if 0 <= nx < n and 0 <= ny < n and self.grid[nx][ny] == 0:\n                            min_flips = min(min_flips, distance2[nx][ny] + 1)\n\n        return min_flips if min_flips != float('inf') else 0", "result": "failed: 'SN_FNE' object has no attribute 'Flip_Number'", "passed": false}
{"task_id": "OOP/72", "completion": "class FOR:\n    def __init__(self, logs):\n        self.logs = logs\n\nclass SN_FOR(FOR):\n    def Final_order(self):\n        letter_logs = []\n        number_logs = []\n\n        for log in self.logs:\n            if log.split()[1].isdigit():\n                number_logs.append(log)\n            else:\n                letter_logs.append(log)\n\n        letter_logs.sort(key=lambda x: (x.split()[1:], x.split()[0]))\n        return letter_logs + number_logs", "result": "failed: ", "passed": false}
{"task_id": "OOP/73", "completion": "class MAR:\n    def __init__(self, drop):\n        self.drop = drop\n\nclass SN_MAR(MAR):\n    def Minimum_Area(self):\n        if len(self.drop) < 4:\n            return 0\n        \n        x_coords = sorted(set(x for x, y in self.drop))\n        y_coords = sorted(set(y for x, y in self.drop))\n        \n        if len(x_coords) < 2 or len(y_coords) < 2:\n            return 0\n        \n        min_x = x_coords[0]\n        max_x = x_coords[-1]\n        min_y = y_coords[0]\n        max_y = y_coords[-1]\n        \n        area = (max_x - min_x) * (max_y - min_y)\n        return area if area > 0 else 0", "result": "failed: ", "passed": false}
{"task_id": "OOP/74", "completion": "class ESU:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_ESU(ESU):\n    def empty_subsequence(self):\n        mod = 10**9 + 7\n        last_seen = {}\n        dp = [1] * (len(self.s) + 1)\n        \n        for i in range(1, len(self.s) + 1):\n            dp[i] = (2 * dp[i - 1]) % mod\n            if self.s[i - 1] in last_seen:\n                dp[i] = (dp[i] - dp[last_seen[self.s[i - 1]] - 1]) % mod\n            last_seen[self.s[i - 1]] = i\n        \n        return (dp[len(self.s)] - 1) % mod", "result": "failed: ", "passed": false}
{"task_id": "OOP/75", "completion": "class MOT:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_MOT(MOT):\n    def Minimum_operations(self):\n        self.nums.sort()\n        operations = 0\n        for i in range(1, len(self.nums)):\n            if self.nums[i] <= self.nums[i - 1]:\n                required_increment = self.nums[i - 1] + 1 - self.nums[i]\n                operations += required_increment\n                self.nums[i] += required_increment\n        return operations", "result": "failed: ", "passed": false}
{"task_id": "OOP/76", "completion": "class ISK:\n    def __init__(self, pushed):\n        self.pushed = pushed\n\nclass SN_ISK(ISK):\n    def __init__(self, pushed, popped):\n        super().__init__(pushed)\n        self.popped = popped\n\n    def Initial_stack(self):\n        stack = []\n        j = 0\n\n        for value in self.pushed:\n            stack.append(value)\n            while stack and stack[-1] == self.popped[j]:\n                stack.pop()\n                j += 1\n\n        return j == len(self.popped) and not stack", "result": "passed", "passed": true}
{"task_id": "OOP/77", "completion": "class RSN:\n    def __init__(self, stones):\n        self.stones = stones\n\nclass SN_RSN(RSN):\n    def Removed_stones(self):\n        if not self.stones:\n            return 0\n\n        rows = set()\n        cols = set()\n        \n        for x, y in self.stones:\n            rows.add(x)\n            cols.add(y)\n\n        return min(len(rows), len(cols))", "result": "failed: ", "passed": false}
{"task_id": "OOP/78", "completion": "class INY:\n    def __init__(self, tokens):\n        self.tokens = tokens\n\nclass SN_INY(INY):\n    def __init__(self, tokens, power):\n        super().__init__(tokens)\n        self.power = power\n\n    def Initial_energy(self):\n        self.tokens.sort()\n        score = 0\n        left = 0\n        right = len(self.tokens) - 1\n        \n        while left <= right:\n            if self.power >= self.tokens[left]:  # Use token face up\n                self.power -= self.tokens[left]\n                score += 1\n                left += 1\n            elif score > 0:  # Use token face down\n                self.power += self.tokens[right]\n                score -= 1\n                right -= 1\n            else:\n                break\n\n        return score", "result": "failed: ", "passed": false}
{"task_id": "OOP/79", "completion": "class ETM:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_ETM(ETM):\n    def effective_time(self):\n        from itertools import permutations\n        \n        max_time = \"\"\n        \n        for p in permutations(self.arr):\n            hours = p[0] * 10 + p[1]\n            minutes = p[2] * 10 + p[3]\n            \n            if hours < 24 and minutes < 60:\n                time_str = f\"{hours:02}:{minutes:02}\"\n                if time_str > max_time:\n                    max_time = time_str\n        \n        return max_time", "result": "failed: ", "passed": false}
{"task_id": "OOP/80", "completion": "class CCN:\n    def __init__(self, nums):\n        self.nums = nums\n\n\nclass SN_CCN(CCN):\n    def __init__(self, nums):\n        super().__init__(nums)\n\n    def find_factors(self, num):\n        factors = set()\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                factors.add(i)\n                factors.add(num // i)\n        return factors\n\n    def Connected_components(self):\n        from collections import defaultdict\n        \n        if not self.nums:\n            return 0\n        \n        factor_to_nodes = defaultdict(set)\n        for index, num in enumerate(self.nums):\n            for factor in self.find_factors(num):\n                factor_to_nodes[factor].add(index)\n\n        visited = [False] * len(self.nums)\n        max_size = 1\n\n        def dfs(node):\n            stack = [node]\n            size = 0\n            while stack:\n                current = stack.pop()\n                if not visited[current]:\n                    visited[current] = True\n                    size += 1\n                    for factor in self.find_factors(self.nums[current]):\n                        for neighbor in factor_to_nodes[factor]:\n                            if not visited[neighbor]:\n                                stack.append(neighbor)\n            return size\n\n        for i in range(len(self.nums)):\n            if not visited[i]:\n                component_size = dfs(i)\n                max_size = max(max_size, component_size)\n\n        return max_size", "result": "failed: ", "passed": false}
{"task_id": "OOP/81", "completion": "class RSF:\n    def __init__(self, arr):\n        self.arr = arr\n\n\nclass SN_RSF(RSF):\n    def Reorganization_satisfaction(self):\n        if len(self.arr) % 2 != 0:\n            return False\n        count = {}\n        for num in self.arr:\n            count[num] = count.get(num, 0) + 1\n        for num in sorted(count.keys()):\n            if count[num] > count.get(2 * num, 0):\n                return False\n            count[2 * num] -= count[num]\n        return True if all(v == 0 for v in count.values()) else False", "result": "failed: ", "passed": false}
{"task_id": "OOP/82", "completion": "class MPL:\n    def __init__(self, strs):\n        self.strs = strs\n\nclass SN_MPL(MPL):\n    def Minimum_possible(self):\n        n = len(self.strs)\n        if n <= 1:\n            return 0\n        \n        m = len(self.strs[0])\n        deletion_indices = set()\n        \n        for col in range(m):\n            temp = [s for i, s in enumerate(self.strs) if i not in deletion_indices]\n            temp.sort()\n            if temp != self.strs:\n                deletion_indices.add(col)\n\n        return len(deletion_indices)", "result": "failed: ", "passed": false}
{"task_id": "OOP/83", "completion": "class IBD:\n    def __init__(self, rods):\n        self.rods = rods\n\nclass SN_IBD(IBD):\n    def Install_billboards(self):\n        total_length = sum(self.rods)\n        if total_length % 2 != 0:\n            return 0\n        half_length = total_length // 2\n        dp = [0] * (half_length + 1)\n        dp[0] = 1\n        \n        for rod in self.rods:\n            for j in range(half_length, rod - 1, -1):\n                if dp[j - rod]:\n                    dp[j] = 1\n        \n        for height in range(half_length, -1, -1):\n            if dp[height]:\n                return height\n        \n        return 0", "result": "failed: ", "passed": false}
{"task_id": "OOP/84", "completion": "class NAS:\n    def __init__(self, grid):\n        self.grid = grid\n\nclass SN_NAS(NAS):\n    def __init__(self, grid):\n        super().__init__(grid)\n\n    def Number_areas(self):\n        n = len(self.grid)\n        visited = [[False] * n for _ in range(n)]\n\n        def dfs(x, y):\n            if x < 0 or x >= n or y < 0 or y >= n or visited[x][y]:\n                return\n            visited[x][y] = True\n            if self.grid[x][y] == '/':\n                dfs(x - 1, y)  # Up\n                dfs(x, y + 1)  # Right\n            elif self.grid[x][y] == '\\\\':\n                dfs(x + 1, y)  # Down\n                dfs(x, y - 1)  # Left\n            else:\n                dfs(x - 1, y)  # Up\n                dfs(x + 1, y)  # Down\n                dfs(x, y - 1)  # Left\n                dfs(x, y + 1)  # Right\n\n        regions = 0\n        for i in range(n):\n            for j in range(n):\n                if not visited[i][j]:\n                    dfs(i, j)\n                    regions += 1\n\n        return regions", "result": "failed: unexpected character after line continuation character (<string>, line 47)", "passed": false}
{"task_id": "OOP/85", "completion": "class MSI:\n    def __init__(self, strs):\n        self.strs = strs\n\n\nclass SN_MSI(MSI):\n    def Minimum_spossible(self):\n        num_strings = len(self.strs)\n        if num_strings == 0:\n            return 0\n        string_length = len(self.strs[0])\n        \n        # Initialize the deletion count\n        deletion_count = 0\n        \n        for col in range(string_length):\n            # Check if current column is sorted\n            for row in range(1, num_strings):\n                if self.strs[row][col] < self.strs[row - 1][col]:\n                    deletion_count += 1\n                    break\n                    \n        return deletion_count", "result": "failed: ", "passed": false}
{"task_id": "OOP/86", "completion": "class WSP:\n    def __init__(self, A):\n        self.A = A\n\nclass SN_WSP(WSP):\n    def Width_slope(self):\n        max_width = 0\n        n = len(self.A)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if self.A[i] <= self.A[j]:\n                    max_width = max(max_width, j - i)\n        return max_width", "result": "failed: ", "passed": false}
{"task_id": "OOP/87", "completion": "class ARE:\n    def __init__(self, drop):\n        self.drop = drop\n\nclass SN_ARE(ARE):\n    def Any_rectangle(self):\n        n = len(self.drop)\n        if n < 4:\n            return 0\n\n        min_area = float('inf')\n        found_rectangle = False\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    for l in range(k + 1, n):\n                        area = self._calculate_area(self.drop[i], self.drop[j], self.drop[k], self.drop[l])\n                        if area > 0:\n                            found_rectangle = True\n                            min_area = min(min_area, area)\n\n        return min_area if found_rectangle else 0\n\n    def _calculate_area(self, p1, p2, p3, p4):\n        def distance(a, b):\n            return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n        d12 = distance(p1, p2)\n        d13 = distance(p1, p3)\n        d14 = distance(p1, p4)\n        d24 = distance(p2, p4)\n        d34 = distance(p3, p4)\n\n        return 0.5 * abs((p1[0] * p2[1] + p2[0] * p3[1] + p3[0] * p4[1] + p4[0] * p1[1]) - \n                          (p2[0] * p1[1] + p3[0] * p2[1] + p4[0] * p3[1] + p1[0] * p4[1]))", "result": "failed: ", "passed": false}
{"task_id": "OOP/88", "completion": "class MNOOT:\n    def __init__(self, x):\n        self.x = x\n\nclass SN_MNOOT(MNOOT):\n    def __init__(self, x, target):\n        super().__init__(x)\n        self.target = target\n\n    def minimum_operators(self):\n        if self.target == self.x:\n            return 0\n        elif self.target % self.x == 0:\n            return self._count_operations(self.target // self.x)\n        elif self.target < self.x:\n            return self._count_operations(self.x - self.target)\n        else:\n            return self._count_operations(self.target - self.x)\n\n    def _count_operations(self, n):\n        count = 0\n        while n > 1:\n            n = n // self.x if n % self.x == 0 else n - self.x\n            count += 1\n        return count", "result": "failed: 'int' object is not callable", "passed": false}
{"task_id": "OOP/89", "completion": "class NIG:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_NIG(NIG):\n    def __init__(self, n, k):\n        super().__init__(n)\n        self.k = k\n\n    def nonnegative_integer(self):\n        results = []\n\n        def backtrack(current_number):\n            if len(current_number) == self.n:\n                results.append(int(current_number))\n                return\n            \n            last_digit = int(current_number[-1])\n            next_digits = set()\n\n            if last_digit + self.k < 10:\n                next_digits.add(last_digit + self.k)\n            if last_digit - self.k >= 0:\n                next_digits.add(last_digit - self.k)\n            \n            for next_digit in next_digits:\n                backtrack(current_number + str(next_digit))\n\n        for starting_digit in range(10):\n            backtrack(str(starting_digit))\n\n        return results", "result": "failed: ", "passed": false}
{"task_id": "OOP/90", "completion": "class PFG:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_PFG(PFG):\n    def Pancake_flipping(self):\n        def flip(sub_array, k):\n            return sub_array[:k][::-1] + sub_array[k:]\n\n        def find_max_index(arr, n):\n            max_index = 0\n            for i in range(1, n):\n                if arr[i] > arr[max_index]:\n                    max_index = i\n            return max_index\n\n        n = len(self.arr)\n        flip_sequence = []\n        for curr_size in range(n, 1, -1):\n            max_index = find_max_index(self.arr, curr_size)\n\n            if max_index + 1 != curr_size:\n                if max_index != 0:\n                    self.arr = flip(self.arr, max_index + 1)\n                    flip_sequence.append(max_index + 1)\n                \n                self.arr = flip(self.arr, curr_size)\n                flip_sequence.append(curr_size)\n\n        return flip_sequence", "result": "failed: ", "passed": false}
{"task_id": "OOP/91", "completion": "class SIG:\n    def __init__(self, x):\n        self.x = x\n\nclass SN_SIG(SIG):\n    def __init__(self, x, y, bound):\n        super().__init__(x)\n        self.y = y\n        self.bound = bound\n\n    def Strong_integer(self):\n        powerful_integers = set()\n        for i in range(20):  # 2^20 is 1048576, more than enough for practical bounds\n            for j in range(20):\n                powerful_integer = (self.x ** i) + (self.y ** j)\n                if powerful_integer <= self.bound:\n                    powerful_integers.add(powerful_integer)\n                if self.x ** i > self.bound and self.y ** j > self.bound:\n                    break\n            if self.x ** i > self.bound:\n                break\n        return sorted(powerful_integers)", "result": "passed", "passed": true}
{"task_id": "OOP/92", "completion": "class SNR:\n    def __init__(self, s: str):\n        self.s = s\n\nclass SN_SNR(SNR):\n    def __init__(self, s: str, t: str):\n        super().__init__(s)\n        self.t = t\n\n    def Same_number(self) -> bool:\n        def parse_number(num: str) -> float:\n            if '.' in num:\n                return float(num)\n            return float(num + '.0')\n\n        return parse_number(self.s) == parse_number(self.t)", "result": "failed: invalid syntax (<string>, line 18)", "passed": false}
{"task_id": "OOP/93", "completion": "class NOG:\n    def __init__(self, points):\n        self.points = points\n\n\nclass SN_NOG(NOG):\n    def __init__(self, points, k):\n        super().__init__(points)\n        self.k = k\n\n    def Nearest_origin(self):\n        self.points.sort(key=lambda point: point[0]**2 + point[1]**2)\n        return self.points[:self.k]", "result": "passed", "passed": true}
{"task_id": "OOP/94", "completion": "class SET:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_SET(SET):\n    def __init__(self, nums, k):\n        super().__init__(nums)\n        self.k = k\n\n    def Sum_Elements(self):\n        count = 0\n        prefix_sum = 0\n        remainder_count = {0: 1}\n        \n        for num in self.nums:\n            prefix_sum += num\n            remainder = prefix_sum % self.k\n            \n            if remainder in remainder_count:\n                count += remainder_count[remainder]\n                \n            if remainder not in remainder_count:\n                remainder_count[remainder] = 0\n            remainder_count[remainder] += 1\n            \n        return count", "result": "passed", "passed": true}
{"task_id": "OOP/95", "completion": "class SID:\n    def __init__(self, A):\n        self.A = A\n\nclass SN_SID(SID):\n    def start_index(self):\n        n = len(self.A)\n        if n == 0:\n            return 0\n        \n        odd_reachable = [False] * n\n        even_reachable = [False] * n\n        odd_reachable[n - 1] = even_reachable[n - 1] = True\n        \n        odd_next = []\n        even_next = []\n        \n        for i in range(n - 2, -1, -1):\n            # Determine the next reachable indices for odd jumps\n            while odd_next and self.A[odd_next[-1]] < self.A[i]:\n                odd_next.pop()\n            if odd_next and self.A[odd_next[-1]] >= self.A[i]:\n                odd_reachable[i] = odd_reachable[odd_next[-1]]\n            odd_next.append(i)\n            \n            # Determine the next reachable indices for even jumps\n            while even_next and self.A[even_next[-1]] > self.A[i]:\n                even_next.pop()\n            if even_next and self.A[even_next[-1]] <= self.A[i]:\n                even_reachable[i] = odd_reachable[even_next[-1]]\n            even_next.append(i)\n\n        good_start_indexes = sum(odd_reachable[i] for i in range(n))\n        return good_start_indexes", "result": "failed: ", "passed": false}
{"task_id": "OOP/96", "completion": "class MTL:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_MTL(MTL):\n    def Maximum_turbulence(self):\n        max_len = 0\n        current_len = 1\n        \n        for i in range(1, len(self.arr)):\n            if (self.arr[i] > self.arr[i - 1] and (i == 1 or self.arr[i - 1] <= self.arr[i - 2])) or \\\n               (self.arr[i] < self.arr[i - 1] and (i == 1 or self.arr[i - 1] >= self.arr[i - 2])):\n                current_len += 1\n            else:\n                max_len = max(max_len, current_len)\n                current_len = 2 if self.arr[i] != self.arr[i - 1] else 1\n        \n        max_len = max(max_len, current_len)\n        return max_len", "result": "failed: ", "passed": false}
{"task_id": "OOP/97", "completion": "class DPS:\n    def __init__(self, grid):\n        self.grid = grid\n    \nclass SN_DPS(DPS):\n    def Different_paths(self):\n        start, end = None, None\n        self.empty_squares = 0\n        \n        for i in range(len(self.grid)):\n            for j in range(len(self.grid[0])):\n                if self.grid[i][j] == 1:\n                    start = (i, j)\n                elif self.grid[i][j] == 2:\n                    end = (i, j)\n                elif self.grid[i][j] == 0:\n                    self.empty_squares += 1\n        \n        if not start or not end:\n            return 0\n        \n        def dfs(x, y, remaining):\n            if (x, y) == end:\n                if remaining == 0:\n                    return 1\n                return 0\n            if not (0 <= x < len(self.grid)) or not (0 <= y < len(self.grid[0])) or self.grid[x][y] == -1:\n                return 0\n            \n            temp = self.grid[x][y]\n            self.grid[x][y] = -1  # mark as visited\n            paths = 0\n            \n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                paths += dfs(x + dx, y + dy, remaining - 1)\n            \n            self.grid[x][y] = temp  # unmark\n            return paths\n        \n        return dfs(start[0], start[1], self.empty_squares)", "result": "failed: ", "passed": false}
{"task_id": "OOP/98", "completion": "class BTT:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_BTT(BTT):\n    def Bitwise_triplet(self):\n        count = 0\n        length = len(self.nums)\n        for i in range(length):\n            for j in range(length):\n                for k in range(length):\n                    if (self.nums[i] & self.nums[j] & self.nums[k]) == 0:\n                        count += 1\n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/99", "completion": "class ASG:\n    def __init__(self, a):\n        self.a = a\n\nclass SN_ASG(ASG):\n    def __init__(self, a, b):\n        super().__init__(a)\n        self.b = b\n\n    def Any_string(self):\n        s = []\n        while self.a > 0 or self.b > 0:\n            if self.a > 0 and (len(s) < 2 or s[-1] != 'a' or s[-2] != 'a'):\n                s.append('a')\n                self.a -= 1\n            elif self.b > 0 and (len(s) < 2 or s[-1] != 'b' or s[-2] != 'b'):\n                s.append('b')\n                self.b -= 1\n            elif self.a > 0:\n                s.append('a')\n                self.a -= 1\n            else:\n                s.append('b')\n                self.b -= 1\n        return ''.join(s)", "result": "passed", "passed": true}
{"task_id": "OOP/100", "completion": "class ILT:\n    def __init__(self, firstList):\n        self.firstList = firstList\n\n\nclass SN_ILT(ILT):\n    def __init__(self, firstList, secondList):\n        super().__init__(firstList)\n        self.secondList = secondList\n\n    def Interval_List(self):\n        intersections = []\n        i, j = 0, 0\n        \n        while i < len(self.firstList) and j < len(self.secondList):\n            start1, end1 = self.firstList[i]\n            start2, end2 = self.secondList[j]\n\n            if end1 < start2:\n                i += 1\n            elif end2 < start1:\n                j += 1\n            else:\n                intersections.append([max(start1, start2), min(end1, end2)])\n                if end1 < end2:\n                    i += 1\n                else:\n                    j += 1\n        \n        return intersections", "result": "passed", "passed": true}
{"task_id": "OOP/101", "completion": "class SVE:\n    def __init__(self, equations):\n        self.equations = equations\n\nclass SN_SVE(SVE):\n    def Single_variable(self):\n        parent = {}\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        # Initialize the parent for each variable\n        for equation in self.equations:\n            a = equation[0]\n            if a not in parent:\n                parent[a] = a\n                \n        # Process all '==' equations to unite the variables\n        for equation in self.equations:\n            if equation[1] == '=':\n                a = equation[0]\n                b = equation[3]\n                parent[find(a)] = find(b)\n\n        # Check all '!=' equations to ensure no contradictions\n        for equation in self.equations:\n            if equation[1] == '!':\n                a = equation[0]\n                b = equation[3]\n                if find(a) == find(b):\n                    return False\n        return True", "result": "failed: 'c'", "passed": false}
{"task_id": "OOP/102", "completion": "class MOS:\n    def __init__(self, startValue):\n        self.startValue = startValue\n\nclass SN_MOS(MOS):\n    def __init__(self, startValue, target):\n        super().__init__(startValue)\n        self.target = target\n\n    def Minimum_operands(self):\n        operations = 0\n        while self.target > self.startValue:\n            if self.target % 2 == 0:\n                self.target //= 2\n            else:\n                self.target += 1\n            operations += 1\n        return operations + (self.startValue - self.target)", "result": "passed", "passed": true}
{"task_id": "OOP/103", "completion": "class GAR:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_GAR(GAR):\n    def __init__(self, nums, k):\n        super().__init__(nums)\n        self.k = k\n\n    def Good_array(self):\n        count = 0\n        nums = self.nums\n        n = len(nums)\n        left = 0\n        right = 0\n        freq = {}\n        \n        while right < n:\n            if nums[right] in freq:\n                freq[nums[right]] += 1\n            else:\n                freq[nums[right]] = 1\n            \n            while len(freq) > self.k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n            \n            if len(freq) == self.k:\n                temp_left = left\n                while len(freq) == self.k:\n                    freq[nums[temp_left]] -= 1\n                    if freq[nums[temp_left]] == 0:\n                        del freq[nums[temp_left]]\n                    temp_left += 1\n                count += temp_left - left\n                \n            right += 1\n            \n        return count", "result": "failed: 1", "passed": false}
{"task_id": "OOP/104", "completion": "class MME:\n    def __init__(self, grid):\n        self.grid = grid\n\nclass SN_MME(MME):\n    def Min_Minutes(self):\n        from collections import deque\n\n        if not self.grid:\n            return -1\n        \n        rows, cols = len(self.grid), len(self.grid[0])\n        queue = deque()\n        fresh_count = 0\n\n        for r in range(rows):\n            for c in range(cols):\n                if self.grid[r][c] == 1:\n                    fresh_count += 1\n                elif self.grid[r][c] == 2:\n                    queue.append((r, c))\n\n        if fresh_count == 0:\n            return 0\n        \n        minutes = 0\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        while queue:\n            for _ in range(len(queue)):\n                r, c = queue.popleft()\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and self.grid[nr][nc] == 1:\n                        self.grid[nr][nc] = 2\n                        fresh_count -= 1\n                        queue.append((nr, nc))\n            minutes += 1\n\n        return minutes if fresh_count == 0 else -1", "result": "failed: ", "passed": false}
{"task_id": "OOP/105", "completion": "class MFI:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_MFI(MFI):\n    def __init__(self, nums, k):\n        super().__init__(nums)\n        self.k = k\n\n    def Min_Flip(self):\n        n = len(self.nums)\n        flip_count = 0\n        flip_effect = [0] * n\n        current_flip = 0\n\n        for i in range(n):\n            current_flip ^= flip_effect[i]\n            if (self.nums[i] ^ current_flip) == 0:  # We have a zero here\n                if i + self.k > n:  # Can't flip as there aren't enough bits\n                    return -1\n                flip_count += 1\n                current_flip ^= 1  # We are flipping\n                if i + self.k < n:\n                    flip_effect[i + self.k] ^= 1  # The end of this flip's effect\n\n        return flip_count", "result": "failed: ", "passed": false}
{"task_id": "OOP/106", "completion": "class SAT:\n    def __init__(self, A):\n        self.A = A\n\nclass SN_SAT(SAT):\n    def is_perfect_square(self, n):\n        if n < 0:\n            return False\n        root = int(n**0.5)\n        return root * root == n\n    \n    def Square_arrangement(self):\n        from itertools import permutations\n        \n        count = 0\n        for perm in permutations(self.A):\n            if all(self.is_perfect_square(perm[i] + perm[i+1]) for i in range(len(perm) - 1)):\n                count += 1\n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/107", "completion": "class SMG:\n    def __init__(self, stones):\n        self.stones = stones\n\nclass SN_SMG(SMG):\n    def __init__(self, stones, k):\n        super().__init__(stones)\n        self.k = k\n\n    def Stone_Merge(self):\n        n = len(self.stones)\n        if n < self.k or (n - self.k) % (self.k - 1) != 0:\n            return -1\n        \n        dp = [[float('inf')] * n for _ in range(n)]\n        cost = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            cost[i][i] = self.stones[i]\n            for j in range(i + 1, n):\n                cost[i][j] = cost[i][j - 1] + self.stones[j]\n\n        for length in range(self.k, n + 1):\n            for i in range(n - length + 1):\n                for j in range(1, self.k + 1):\n                    if i + j - 1 < n and length - j >= self.k - 1:\n                        dp[i][i + length - 1] = min(dp[i][i + length - 1], dp[i][i + length - j] + cost[i + length - j][i + length - 1])\n\n        return dp[0][n - 1] if dp[0][n - 1] != float('inf') else -1", "result": "failed: ", "passed": false}
{"task_id": "OOP/108", "completion": "class DMS:\n    def __init__(self, tops):\n        self.tops = tops\n\nclass SN_DMS(DMS):\n    def __init__(self, tops, bottoms):\n        super().__init__(tops)\n        self.bottoms = bottoms\n\n    def Dominoes(self):\n        def min_rotations(target):\n            top_rotations = sum(1 for i in range(len(self.tops)) if self.tops[i] != target and self.bottoms[i] != target)\n            bottom_rotations = sum(1 for i in range(len(self.bottoms)) if self.bottoms[i] != target and self.tops[i] != target)\n            return min(top_rotations, bottom_rotations)\n        \n        candidates = {self.tops[0], self.bottoms[0]}\n        min_rotations_count = float('inf')\n\n        for candidate in candidates:\n            rotations = min_rotations(candidate)\n            if rotations >= 0:\n                min_rotations_count = min(min_rotations_count, rotations)\n\n        return min_rotations_count if min_rotations_count != float('inf') else -1", "result": "failed: ", "passed": false}
{"task_id": "OOP/109", "completion": "class TDN:\n    def __init__(self, time):\n        self.time = time\n\nclass SN_TDN(TDN):\n    def Total_duration(self):\n        count = 0\n        remainder_count = [0] * 60\n        \n        for t in self.time:\n            remainder = t % 60\n            complement = (60 - remainder) % 60\n            count += remainder_count[complement]\n            remainder_count[remainder] += 1\n        \n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/110", "completion": "class MCG:\n    def __init__(self, weights):\n        self.weights = weights\n\nclass SN_MCG(MCG):\n    def __init__(self, weights, days):\n        super().__init__(weights)\n        self.days = days\n\n    def Minimum_carrying(self):\n        def canDeliver(capacity):\n            current_weight = 0\n            days_needed = 1\n            for weight in self.weights:\n                if current_weight + weight > capacity:\n                    days_needed += 1\n                    current_weight = weight\n                    if days_needed > self.days:\n                        return False\n                else:\n                    current_weight += weight\n            return True\n\n        left = max(self.weights)\n        right = sum(self.weights)\n        while left < right:\n            mid = (left + right) // 2\n            if canDeliver(mid):\n                right = mid\n            else:\n                left = mid + 1\n\n        return left", "result": "passed", "passed": true}
{"task_id": "OOP/111", "completion": "class RNS:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_RNS(RNS):\n    def Repeating_numbers(self):\n        def has_repeating_digits(num):\n            seen = set()\n            while num > 0:\n                digit = num % 10\n                if digit in seen:\n                    return True\n                seen.add(digit)\n                num //= 10\n            return False\n        \n        count = 0\n        for i in range(1, self.n + 1):\n            if has_repeating_digits(i):\n                count += 1\n                \n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/112", "completion": "class SCT:\n    def __init__(self, values):\n        self.values = values\n\nclass SN_SCT(SCT):\n    def Sightseeing_combination(self):\n        max_score = float('-inf')\n        n = len(self.values)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                score = self.values[i] + self.values[j] + i - j\n                max_score = max(max_score, score)\n        \n        return max_score", "result": "failed: ", "passed": false}
{"task_id": "OOP/113", "completion": "class MIR:\n    def __init__(self, k):\n        self.k = k\n\nclass SN_MIR(MIR):\n    def Minimum_integer(self):\n        if self.k == 0:\n            return -1\n        \n        remainder = 1 % self.k\n        count = 1\n        \n        while remainder != 0:\n            remainder = (remainder * 10 + 1) % self.k\n            count += 1\n            \n            if count > self.k * 10:  # Avoid infinite loops\n                return -1\n        \n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/114", "completion": "class ETG:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_ETG(ETG):\n    def __init__(self, s, n):\n        super().__init__(s)\n        self.n = n\n\n    def Each_integer(self):\n        for i in range(1, self.n + 1):\n            if bin(i)[2:] not in self.s:\n                return False\n        return True", "result": "passed", "passed": true}
{"task_id": "OOP/115", "completion": "class NGY:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_NGY(NGY):\n    def negabinary(self):\n        if self.n == 0:\n            return \"0\"\n        n = self.n\n        result = []\n        while n != 0:\n            remainder = n % -2\n            n //= -2\n            if remainder < 0:\n                remainder += 2\n                n += 1\n            result.append(str(remainder))\n        result.reverse()\n        return ''.join(result)", "result": "failed: ", "passed": false}
{"task_id": "OOP/116", "completion": "class LNS:\n    def __init__(self, head):\n        self.head = head\n\nclass SN_LNS(LNS):\n    def Larger_nodes(self):\n        answer = []\n        current = self.head\n        stack = []\n        nodes = []\n        \n        while current:\n            nodes.append(current.val)\n            current = current.next\n\n        for value in nodes:\n            while stack and stack[-1] <= value:\n                stack.pop()\n            if stack:\n                answer.append(stack[-1])\n            else:\n                answer.append(0)\n            stack.append(value)\n\n        return answer", "result": "failed: 'list' object has no attribute 'val'", "passed": false}
{"task_id": "OOP/117", "completion": "class LCL:\n    def __init__(self, grid):\n        self.grid = grid\n\nclass SN_LCL(LCL):\n    def Land_Cell(self):\n        if not self.grid:\n            return 0\n\n        m, n = len(self.grid), len(self.grid[0])\n        visited = [[False]*n for _ in range(m)]\n\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or self.grid[i][j] == 0:\n                return\n            visited[i][j] = True\n            dfs(i-1, j)\n            dfs(i+1, j)\n            dfs(i, j-1)\n            dfs(i, j+1)\n\n        # Mark land cells connected to the borders\n        for i in range(m):\n            for j in range(n):\n                if (i == 0 or i == m-1 or j == 0 or j == n-1) and self.grid[i][j] == 1 and not visited[i][j]:\n                    dfs(i, j)\n\n        # Count the land cells that cannot leave the grid border\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if self.grid[i][j] == 1 and not visited[i][j]:\n                    count += 1\n\n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/118", "completion": "class BAY:\n    def __init__(self, queries):\n        self.queries = queries\n\nclass SN_BAY(BAY):\n    def __init__(self, queries, pattern):\n        super().__init__(queries)\n        self.pattern = pattern\n\n    def boolean_array(self):\n        return [query == self.pattern for query in self.queries]", "result": "failed: ", "passed": false}
{"task_id": "OOP/119", "completion": "class LSQ:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_LSQ(LSQ):\n    def Longest_subsequence(self):\n        if not self.nums:\n            return 0\n        \n        n = len(self.nums)\n        dp = {}\n        max_length = 0\n        \n        for j in range(n):\n            for i in range(j):\n                diff = self.nums[j] - self.nums[i]\n                if (i, diff) in dp:\n                    dp[j, diff] = dp[i, diff] + 1\n                else:\n                    dp[j, diff] = 2\n                max_length = max(max_length, dp[j, diff])\n        \n        return max_length if max_length >= 2 else 0", "result": "failed: ", "passed": false}
{"task_id": "OOP/120", "completion": "class MCT:\n    def __init__(self, costs):\n        self.costs = costs\n\nclass SN_MCT(MCT):\n    def Minimum_cost(self):\n        n = len(self.costs) // 2\n        costs_diff = sorted(self.costs, key=lambda x: x[0] - x[1])\n        min_cost = sum(cost[0] for cost in costs_diff[:n]) + sum(cost[1] for cost in costs_diff[n:])\n        return min_cost", "result": "failed: ", "passed": false}
{"task_id": "OOP/121", "completion": "class OSR:\n    def __init__(self, nums):\n        self.nums = nums\n\nclass SN_OSR(OSR):\n    def __init__(self, nums, firstLen, secondLen):\n        super().__init__(nums)\n        self.firstLen = firstLen\n        self.secondLen = secondLen\n\n    def overlapping_subarray(self):\n        n = len(self.nums)\n        max_sum = 0\n        \n        # Calculate prefix sums\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + self.nums[i]\n        \n        # Find the maximum sum of two non-overlapping subarrays\n        for i in range(n):\n            if i + self.firstLen <= n:\n                first_sum = prefix_sum[i + self.firstLen] - prefix_sum[i]\n                # Check second subarray starting after the first\n                for j in range(i + self.firstLen, n):\n                    if j + self.secondLen <= n:\n                        second_sum = prefix_sum[j + self.secondLen] - prefix_sum[j]\n                        max_sum = max(max_sum, first_sum + second_sum)\n\n            if i + self.secondLen <= n:\n                second_sum = prefix_sum[i + self.secondLen] - prefix_sum[i]\n                # Check first subarray starting after the second\n                for j in range(i + self.secondLen, n):\n                    if j + self.firstLen <= n:\n                        first_sum = prefix_sum[j + self.firstLen] - prefix_sum[j]\n                        max_sum = max(max_sum, first_sum + second_sum)\n\n        return max_sum", "result": "passed", "passed": true}
{"task_id": "OOP/122", "completion": "class SMT:\n    def __init__(self, a):\n        self.a = a\n\n\nclass SN_SMT(SMT):\n    def __init__(self, a, b, c):\n        super().__init__(a)\n        self.b = b\n        self.c = c\n\n    def Stone_movement(self):\n        x, y, z = sorted([self.a, self.b, self.c])\n        \n        # For minimum moves: we can always make one move if there's a gap.\n        min_moves = 0\n        if z - y > 1 and y - x > 1:  # At least one gap on each side\n            min_moves = 1\n        elif z - y > 1 or y - x > 1:  # At least one gap\n            min_moves = 1\n            \n        # For maximum moves: we can only make a move until the stones are consecutive\n        max_moves = (y - x - 1) + (z - y - 1)\n        \n        return [min_moves, max_moves]", "result": "passed", "passed": true}
{"task_id": "OOP/123", "completion": "class MCT:\n    def __init__(self, nums1):\n        self.nums1 = nums1\n\nclass SN_MCT(MCT):\n    def __init__(self, nums1, nums2):\n        super().__init__(nums1)\n        self.nums2 = nums2\n\n    def max_connections(self):\n        from collections import defaultdict\n\n        # Creating a mapping of indices for nums2\n        index_map = defaultdict(list)\n        for index, value in enumerate(self.nums2):\n            index_map[value].append(index)\n\n        connections = 0\n        last_index = -1\n\n        for value in self.nums1:\n            if value in index_map:\n                for index in index_map[value]:\n                    if index > last_index:\n                        connections += 1\n                        last_index = index\n                        break\n\n        return connections", "result": "passed", "passed": true}
{"task_id": "OOP/124", "completion": "class SGD:\n    def __init__(self, blocked):\n        self.blocked = set(tuple(cell) for cell in blocked)\n\nclass SN_SGD(SGD):\n    def __init__(self, blocked, source, target):\n        super().__init__(blocked)\n        self.source = tuple(source)\n        self.target = tuple(target)\n\n    def Source_grid(self):\n        from collections import deque\n        \n        if self.source == self.target:\n            return True\n        \n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque([self.source])\n        visited = set([self.source])\n        \n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if (0 <= nx < 10**6 and 0 <= ny < 10**6 and\n                        (nx, ny) not in visited and\n                        (nx, ny) not in self.blocked):\n                    if (nx, ny) == self.target:\n                        return True\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        \n        return False", "result": "timed out", "passed": false}
{"task_id": "OOP/125", "completion": "class TGT:\n    def __init__(self, values):\n        self.values = values\n\nclass SN_TGT(TGT):\n    def triangulation(self):\n        n = len(self.values)\n        if n < 3:\n            return 0\n        \n        # Create a DP table for storing the minimum score\n        dp = [[0] * n for _ in range(n)]\n        \n        # Fill the DP table\n        for length in range(2, n):  # length of the triangle side\n            for i in range(n - length):\n                j = i + length\n                dp[i][j] = float('inf')\n                \n                for k in range(i + 1, j):\n                    score = self.values[i] * self.values[k] * self.values[j]\n                    total = dp[i][k] + dp[k][j] + score\n                    dp[i][j] = min(dp[i][j], total)\n        \n        return dp[0][n - 1]", "result": "failed: ", "passed": false}
{"task_id": "OOP/126", "completion": "class EIT:\n    def __init__(self, instructions):\n        self.instructions = instructions\n\nclass SN_EIT(EIT):\n    def __init__(self, instructions):\n        super().__init__(instructions)\n\n    def Execute_instructions(self):\n        # Directions represent North, East, South, West respectively\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        x, y = 0, 0\n        direction_index = 0\n        \n        for instruction in self.instructions:\n            if instruction == 'G':\n                x += directions[direction_index][0]\n                y += directions[direction_index][1]\n            elif instruction == 'L':\n                direction_index = (direction_index - 1) % 4\n            elif instruction == 'R':\n                direction_index = (direction_index + 1) % 4\n        \n        # If the robot is at the original position (0, 0) or not facing North, it's a loop\n        return (x == 0 and y == 0) or direction_index != 0", "result": "passed", "passed": true}
{"task_id": "OOP/127", "completion": "class PFS:\n    def __init__(self, n):\n        self.n = n\n\n\nclass SN_PFS(PFS):\n    def __init__(self, n, paths):\n        super().__init__(n)\n        self.paths = paths\n\n    def Planted_flowers(self):\n        graph = {i: [] for i in range(1, self.n + 1)}\n        for x, y in self.paths:\n            graph[x].append(y)\n            graph[y].append(x)\n\n        flower_assignment = [0] * self.n\n        for garden in range(1, self.n + 1):\n            if flower_assignment[garden - 1] == 0:\n                used_flowers = set()\n                for neighbor in graph[garden]:\n                    if flower_assignment[neighbor - 1] != 0:\n                        used_flowers.add(flower_assignment[neighbor - 1])\n\n                for flower in range(1, 5):\n                    if flower not in used_flowers:\n                        flower_assignment[garden - 1] = flower\n                        break\n\n        return flower_assignment", "result": "passed", "passed": true}
{"task_id": "OOP/128", "completion": "class STF:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_STF(STF):\n    def __init__(self, arr, k):\n        super().__init__(arr)\n        self.k = k\n\n    def Separation_transformation(self):\n        n = len(self.arr)\n        max_sum = 0\n        for i in range(0, n, self.k):\n            sub_array = self.arr[i:i + self.k]\n            max_value = max(sub_array)\n            max_sum += max_value\n        return max_sum", "result": "failed: ", "passed": false}
{"task_id": "OOP/129", "completion": "class RST:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_RST(RST):\n    def Repeated_substring(self):\n        n = len(self.s)\n        suffixes = [self.s[i:] for i in range(n)]\n        suffixes.sort()\n        \n        longest_substring = \"\"\n        \n        for i in range(n - 1):\n            lcp = self._longest_common_prefix(suffixes[i], suffixes[i + 1])\n            if lcp > len(longest_substring):\n                longest_substring = suffixes[i][:lcp]\n        \n        return longest_substring\n\n    def _longest_common_prefix(self, s1, s2):\n        lcp_length = 0\n        min_length = min(len(s1), len(s2))\n        while lcp_length < min_length and s1[lcp_length] == s2[lcp_length]:\n            lcp_length += 1\n        return lcp_length", "result": "failed: ", "passed": false}
{"task_id": "OOP/130", "completion": "class FCA:\n    def __init__(self, words):\n        self.words = words\n\nclass SN_FCA(FCA):\n    def Form_chain(self):\n        def is_predecessor(wordA, wordB):\n            if len(wordB) - len(wordA) != 1:\n                return False\n            i, j = 0, 0\n            while i < len(wordA) and j < len(wordB):\n                if wordA[i] == wordB[j]:\n                    i += 1\n                j += 1\n            return i == len(wordA)\n\n        dp = [1] * len(self.words)\n        self.words.sort(key=len)\n\n        max_length = 1\n\n        for i in range(len(self.words)):\n            for j in range(i):\n                if is_predecessor(self.words[j], self.words[i]):\n                    dp[i] = max(dp[i], dp[j] + 1)\n            max_length = max(max_length, dp[i])\n\n        return max_length", "result": "failed: ", "passed": false}
{"task_id": "OOP/131", "completion": "class MWG:\n    def __init__(self, stones):\n        self.stones = stones\n\nclass SN_MWG(MWG):\n    def Minimum_weight(self):\n        import heapq\n        \n        heapq.heapify(self.stones)\n        \n        while len(self.stones) > 1:\n            first = heapq.heappop(self.stones)\n            second = heapq.heappop(self.stones)\n            \n            if first != second:\n                heapq.heappush(self.stones, second - first)\n        \n        return self.stones[0] if self.stones else 0", "result": "failed: ", "passed": false}
{"task_id": "OOP/132", "completion": "class OEH:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_OEH(OEH):\n    def One_exchange(self):\n        n = len(self.arr)\n        if n <= 1:\n            return self.arr\n\n        # Create a list to track the last occurrence of each number\n        last_occurrence = {}\n        for i in range(n):\n            last_occurrence[self.arr[i]] = i\n\n        # Try to find the first element that can be swapped to make the array smaller\n        for i in range(n):\n            # Look for a smaller number that occurs later in the array\n            for j in range(self.arr[i] - 1, -1, -1):\n                if j in last_occurrence and last_occurrence[j] > i:\n                    # Swap and return the result\n                    self.arr[i], self.arr[last_occurrence[j]] = self.arr[last_occurrence[j]], self.arr[i]\n                    return self.arr\n\n        return self.arr", "result": "failed: ", "passed": false}
{"task_id": "OOP/133", "completion": "class ABD:\n    def __init__(self, barcodes):\n        self.barcodes = barcodes\n\nclass SN_ABD(ABD):\n    def Adjacent_barcodes(self):\n        from collections import Counter\n        from heapq import heappop, heappush\n\n        barcode_count = Counter(self.barcodes)\n        max_heap = []\n        \n        for barcode, count in barcode_count.items():\n            heappush(max_heap, (-count, barcode))\n\n        previous_barcode = None\n        previous_count = 0\n        result = []\n\n        while max_heap:\n            count, barcode = heappop(max_heap)\n            result.append(barcode)\n\n            if previous_count < 0:\n                heappush(max_heap, (previous_count, previous_barcode))\n\n            previous_barcode = barcode\n            previous_count = count + 1\n\n        return result", "result": "failed: ", "passed": false}
{"task_id": "OOP/134", "completion": "class EST:\n    def __init__(self, s1):\n        self.s1 = s1\n\nclass SN_EST(EST):\n    def __init__(self, s1, s2, baseStr):\n        super().__init__(s1)\n        self.s2 = s2\n        self.baseStr = baseStr\n\n    def find_equivalence(self, char, mapping):\n        if char not in mapping:\n            mapping[char] = char\n        if mapping[char] != char:\n            mapping[char] = self.find_equivalence(mapping[char], mapping)\n        return mapping[char]\n    \n    def Equivalent_String(self):\n        mapping = {}\n        for a, b in zip(self.s1, self.s2):\n            self.find_equivalence(a, mapping)\n            self.find_equivalence(b, mapping)\n            rootA = self.find_equivalence(a, mapping)\n            rootB = self.find_equivalence(b, mapping)\n            if rootA < rootB:\n                mapping[rootB] = rootA\n            else:\n                mapping[rootA] = rootB\n        \n        result = []\n        for char in self.baseStr:\n            result.append(self.find_equivalence(char, mapping))\n        return ''.join(result)", "result": "passed", "passed": true}
{"task_id": "OOP/135", "completion": "class MRW:\n    def __init__(self, matrix):\n        self.matrix = matrix\n\nclass SN_MRW(MRW):\n    def Maximum_rows(self):\n        from collections import Counter\n        \n        row_length = len(self.matrix[0])\n        count = Counter()\n        \n        for row in self.matrix:\n            # Create a tuple representing the row after potential flips\n            key = tuple(val if i % 2 == 0 else 1 - val for i, val in enumerate(row))\n            count[key] += 1\n        \n        return max(count.values()) if count else 0", "result": "failed: ", "passed": false}
{"task_id": "OOP/136", "completion": "class ANS:\n    def __init__(self, arr1):\n        self.arr1 = arr1\n\nclass SN_ANS(ANS):\n    def __init__(self, arr1, arr2):\n        super().__init__(arr1)\n        self.arr2 = arr2\n\n    def Adding_Numbers(self):\n        def base_negative_two_to_decimal(arr):\n            decimal = 0\n            for i, digit in enumerate(reversed(arr)):\n                decimal += digit * ((-2) ** i)\n            return decimal\n        \n        def decimal_to_base_negative_two(num):\n            if num == 0:\n                return [0]\n            result = []\n            while num != 0:\n                num, remainder = divmod(num, -2)\n                if remainder < 0:\n                    num += 1\n                    remainder += 2\n                result.append(remainder)\n            return result[::-1]\n\n        decimal_sum = base_negative_two_to_decimal(self.arr1) + base_negative_two_to_decimal(self.arr2)\n        return decimal_to_base_negative_two(decimal_sum)", "result": "passed", "passed": true}
{"task_id": "OOP/137", "completion": "class ESI:\n    def __init__(self, matrix):\n        self.matrix = matrix\n\nclass SN_ESI(ESI):\n    def __init__(self, matrix, target):\n        super().__init__(matrix)\n        self.target = target\n\n    def empty_submatrix(self):\n        count = 0\n        rows = len(self.matrix)\n        cols = len(self.matrix[0]) if rows > 0 else 0\n        \n        for left in range(cols):\n            sums = [0] * rows\n            for right in range(left, cols):\n                for row in range(rows):\n                    sums[row] += self.matrix[row][right]\n                    \n                count += self._count_subarrays_with_sum(sums, self.target)\n        \n        return count\n\n    def _count_subarrays_with_sum(self, nums, target):\n        count = 0\n        cumulative_sum = 0\n        sum_count = {0: 1}\n        \n        for num in nums:\n            cumulative_sum += num\n            if cumulative_sum - target in sum_count:\n                count += sum_count[cumulative_sum - target]\n            sum_count[cumulative_sum] = sum_count.get(cumulative_sum, 0) + 1\n            \n        return count", "result": "passed", "passed": true}
{"task_id": "OOP/138", "completion": "class LSQ:\n    def __init__(self, tiles):\n        self.tiles = tiles\n\nclass SN_LSQ(LSQ):\n    def letter_sequence(self):\n        from collections import Counter\n\n        def backtrack(count):\n            total_sequences = 0\n            for i in range(len(count)):\n                if count[i] > 0:\n                    total_sequences += 1\n                    count[i] -= 1\n                    total_sequences += backtrack(count)\n                    count[i] += 1\n            return total_sequences\n        \n        count = Counter(self.tiles)\n        return backtrack(list(count.values()))", "result": "failed: ", "passed": false}
{"task_id": "OOP/139", "completion": "class SSU:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_SSU(SSU):\n    def smallest_subsequence(self):\n        last_occurrence = {char: i for i, char in enumerate(self.s)}\n        stack = []\n        seen = set()\n        \n        for i, char in enumerate(self.s):\n            if char in seen:\n                continue\n            while stack and char < stack[-1] and last_occurrence[stack[-1]] > i:\n                seen.remove(stack.pop())\n            stack.append(char)\n            seen.add(char)\n        \n        return ''.join(stack)", "result": "failed: ", "passed": false}
{"task_id": "OOP/140", "completion": "class MSR:\n    def __init__(self, values):\n        self.values = values\n\nclass SN_MSR(MSR):\n    def __init__(self, values, labels, numWanted, useLimit):\n        super().__init__(values)\n        self.labels = labels\n        self.numWanted = numWanted\n        self.useLimit = useLimit\n\n    def Maximum_score(self):\n        from collections import defaultdict\n\n        item_info = sorted(zip(self.values, self.labels), key=lambda x: x[0], reverse=True)\n        \n        label_count = defaultdict(int)\n        score = 0\n        count = 0\n        \n        for value, label in item_info:\n            if count < self.numWanted:\n                if label_count[label] < self.useLimit:\n                    score += value\n                    label_count[label] += 1\n                    count += 1\n        \n        return score", "result": "passed", "passed": true}
{"task_id": "OOP/141", "completion": "class UPT:\n    def __init__(self, grid):\n        self.grid = grid\n\nclass SN_UPT(UPT):\n    def unobstructed_path(self):\n        from collections import deque\n        \n        n = len(self.grid)\n        if self.grid[0][0] == 1 or self.grid[n-1][n-1] == 1:\n            return -1\n        \n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque([(0, 0, 1)])  # (row, col, length)\n        visited = set((0, 0))\n        \n        while queue:\n            x, y, length = queue.popleft()\n            \n            if x == n - 1 and y == n - 1:\n                return length\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and self.grid[nx][ny] == 0:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, length + 1))\n        \n        return -1", "result": "failed: 'SN_UPT' object has no attribute 'Unobstructed_path'", "passed": false}
{"task_id": "OOP/142", "completion": "class SSI:\n    def __init__(self, str1):\n        self.str1 = str1\n\nclass SN_SSI(SSI):\n    def __init__(self, str1, str2):\n        super().__init__(str1)\n        self.str2 = str2\n\n    def Shortest_string(self):\n        len1, len2 = len(self.str1), len(self.str2)\n        dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n\n        for i in range(len1 + 1):\n            for j in range(len2 + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif self.str1[i - 1] == self.str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n\n        shortest_length = dp[len1][len2]\n        result = []\n        i, j = len1, len2\n\n        while i > 0 and j > 0:\n            if self.str1[i - 1] == self.str2[j - 1]:\n                result.append(self.str1[i - 1])\n                i -= 1\n                j -= 1\n            elif dp[i - 1][j] < dp[i][j - 1]:\n                result.append(self.str1[i - 1])\n                i -= 1\n            else:\n                result.append(self.str2[j - 1])\n                j -= 1\n\n        while i > 0:\n            result.append(self.str1[i - 1])\n            i -= 1\n\n        while j > 0:\n            result.append(self.str2[j - 1])\n            j -= 1\n\n        return ''.join(reversed(result))", "result": "passed", "passed": true}
{"task_id": "OOP/143", "completion": "class PPG:\n    def __init__(self, trips):\n        self.trips = trips\n\nclass SN_PPG(PPG):\n    def __init__(self, trips, capacity):\n        super().__init__(trips)\n        self.capacity = capacity\n\n    def Pick_passengers(self):\n        events = []\n        for numPassengers, from_i, to_i in self.trips:\n            events.append((from_i, numPassengers))  # Pickup event\n            events.append((to_i, -numPassengers))   # Drop-off event\n        \n        events.sort()  # Sort events based on location\n\n        current_passengers = 0\n        for _, change in events:\n            current_passengers += change\n            if current_passengers > self.capacity:\n                return False\n        \n        return True", "result": "passed", "passed": true}
{"task_id": "OOP/144", "completion": "class MAR:\n    def __init__(self, array):\n        self.array = array\n\nclass SN_MAR(MAR):\n    def __init__(self, array, target):\n        super().__init__(array)\n        self.target = target\n    \n    def Mountain_array(self):\n        left, right = 0, len(self.array) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if self.array[mid] == self.target:\n                # Find the first occurrence\n                while mid > 0 and self.array[mid - 1] == self.target:\n                    mid -= 1\n                return mid\n            elif self.array[mid] < self.target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1", "result": "passed", "passed": true}
{"task_id": "OOP/145", "completion": "class BLS:\n    def __init__(self, expression: str):\n        self.expression = expression\n\nclass SN_BLS(BLS):\n    def Booleans(self) -> bool:\n        def evaluate(expr: str) -> bool:\n            if expr == 't':\n                return True\n            elif expr == 'f':\n                return False\n            elif expr[0] == '!':\n                return not evaluate(expr[2:-1])\n            elif expr[0] == '&':\n                return all(evaluate(e.strip()) for e in expr[2:-1].split(','))\n            elif expr[0] == '|':\n                return any(evaluate(e.strip()) for e in expr[2:-1].split(','))\n            return False\n        \n        return evaluate(self.expression)", "result": "failed: ", "passed": false}
{"task_id": "OOP/146", "completion": "class RSA:\n    def __init__(self, bookings):\n        self.bookings = bookings\n\nclass SN_RSA(RSA):\n    def __init__(self, bookings, n):\n        super().__init__(bookings)\n        self.n = n\n\n    def Reserved_seats(self):\n        answer = [0] * self.n\n        for first, last, seats in self.bookings:\n            answer[first - 1] += seats\n            if last < self.n:\n                answer[last] -= seats\n        \n        for i in range(1, self.n):\n            answer[i] += answer[i - 1]\n        \n        return answer", "result": "failed: ", "passed": false}
{"task_id": "OOP/147", "completion": "class PWL:\n    def __init__(self, hours):\n        self.hours = hours\n\nclass SN_PWL(PWL):\n    def Performing_well(self):\n        n = len(self.hours)\n        max_length = 0\n        \n        for start in range(n):\n            tiring_days = 0\n            non_tiring_days = 0\n            \n            for end in range(start, n):\n                if self.hours[end] > 8:\n                    tiring_days += 1\n                else:\n                    non_tiring_days += 1\n                \n                if tiring_days > non_tiring_days:\n                    max_length = max(max_length, end - start + 1)\n\n        return max_length", "result": "failed: ", "passed": false}
{"task_id": "OOP/148", "completion": "class NTM:\n    def __init__(self, req_skills):\n        self.req_skills = req_skills\n\n\nclass SN_NTM(NTM):\n    def __init__(self, req_skills, people):\n        super().__init__(req_skills)\n        self.people = people\n\n    def Necessary_team(self):\n        from itertools import combinations\n\n        skill_to_people = {}\n        for i, skills in enumerate(self.people):\n            for skill in skills:\n                if skill not in skill_to_people:\n                    skill_to_people[skill] = []\n                skill_to_people[skill].append(i)\n\n        req_skills_count = len(self.req_skills)\n        for team_size in range(1, len(self.people) + 1):\n            for team in combinations(range(len(self.people)), team_size):\n                mastered_skills = set()\n                for member in team:\n                    mastered_skills.update(self.people[member])\n                if len(mastered_skills) == req_skills_count and all(skill in mastered_skills for skill in self.req_skills):\n                    return list(team)", "result": "passed", "passed": true}
{"task_id": "OOP/149", "completion": "class AAR:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_AAR(AAR):\n    def __init__(self, n, red_edges, blue_edges):\n        super().__init__(n)\n        self.red_edges = red_edges\n        self.blue_edges = blue_edges\n\n    def Alternating_appearance(self):\n        from collections import deque, defaultdict\n\n        graph = defaultdict(list)\n        for a, b in self.red_edges:\n            graph[a].append((b, 'red'))\n        for u, v in self.blue_edges:\n            graph[u].append((v, 'blue'))\n\n        answer = [-1] * self.n\n        answer[0] = 0\n        queue = deque([(0, 'red', 0), (0, 'blue', 0)])  # (current_node, last_color, distance)\n\n        while queue:\n            node, last_color, dist = queue.popleft()\n\n            for neighbor, color in graph[node]:\n                if color != last_color:  # Alternate the edge color\n                    if answer[neighbor] == -1:  # Not visited\n                        answer[neighbor] = dist + 1\n                        queue.append((neighbor, color, dist + 1))\n\n        return answer", "result": "passed", "passed": true}
{"task_id": "OOP/150", "completion": "class MES:\n    def __init__(self, arr1):\n        self.arr1 = arr1\n\nclass SN_MES(MES):\n    def __init__(self, arr1, arr2):\n        super().__init__(arr1)\n        self.arr2 = arr2\n\n    def Maximum_expression(self):\n        n = len(self.arr1)\n        max_value = 0\n        for i in range(n):\n            for j in range(n):\n                current_value = abs(self.arr1[i] - self.arr1[j]) + abs(self.arr2[i] - self.arr2[j]) + abs(i - j)\n                max_value = max(max_value, current_value)\n        return max_value", "result": "passed", "passed": true}
{"task_id": "OOP/151", "completion": "class SSR:\n    def __init__(self, grid):\n        self.grid = grid\n\nclass SN_GGG(SSR):\n    def Square_subgrid(self):\n        if not self.grid or not self.grid[0]:\n            return 0\n        \n        rows, cols = len(self.grid), len(self.grid[0])\n        max_side = 0\n        \n        # Create a 2D dp array to store the size of the largest square sub-grid found\n        dp = [[0] * cols for _ in range(rows)]\n        \n        for i in range(rows):\n            for j in range(cols):\n                if self.grid[i][j] == 1:\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                    \n                    max_side = max(max_side, dp[i][j])\n        \n        return max_side * max_side  # Return the area of the largest square sub-grid found: side^2", "result": "failed: ", "passed": false}
{"task_id": "OOP/152", "completion": "class SGA:\n    def __init__(self, piles):\n        self.piles = piles\n\nclass SN_SGA(SGA):\n    def Stone_Game(self):\n        n = len(self.piles)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        \n        for i in range(n):\n            dp[i][i + 1] = self.piles[i]\n\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length\n                dp[i][j] = max(sum(self.piles[i:j]) - dp[i + x][j] for x in range(1, min(2 * (length - 1), j - i) + 1))\n\n        return dp[0][n]", "result": "failed: ", "passed": false}
{"task_id": "OOP/153", "completion": "class SSN:\n    def __init__(self, text1):\n        self.text1 = text1\n\nclass SN_SSN(SSN):\n    def __init__(self, text1, text2):\n        super().__init__(text1)\n        self.text2 = text2\n\n    def Shared_subsequences(self):\n        m, n = len(self.text1), len(self.text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if self.text1[i - 1] == self.text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[m][n]", "result": "passed", "passed": true}
{"task_id": "OOP/154", "completion": "class JAR:\n    def __init__(self, nums):\n        self.nums = nums\n\n\nclass SN_JAR(JAR):\n    def Jagged_array(self):\n        even_operations = 0\n        odd_operations = 0\n        n = len(self.nums)\n\n        for i in range(n):\n            if i % 2 == 0:  # even index\n                if i > 0 and self.nums[i] <= self.nums[i - 1]:\n                    even_operations += self.nums[i - 1] - self.nums[i] + 1\n                if i < n - 1 and self.nums[i] <= self.nums[i + 1]:\n                    even_operations += self.nums[i + 1] - self.nums[i] + 1\n            else:  # odd index\n                if i > 0 and self.nums[i] <= self.nums[i - 1]:\n                    odd_operations += self.nums[i - 1] - self.nums[i] + 1\n                if i < n - 1 and self.nums[i] <= self.nums[i + 1]:\n                    odd_operations += self.nums[i + 1] - self.nums[i] + 1\n\n        return min(even_operations, odd_operations)", "result": "failed: ", "passed": false}
{"task_id": "OOP/155", "completion": "class ESI:\n    def __init__(self, text):\n        self.text = text\n\nclass SN_ESI(ESI):\n    def empty_string(self):\n        n = len(self.text)\n        max_k = 0\n        \n        for i in range(1, n + 1):\n            if n % i == 0:\n                substring = self.text[:i]\n                repeats = n // i\n                if substring * repeats == self.text:\n                    max_k = repeats\n\n        return max_k", "result": "failed: ", "passed": false}
{"task_id": "OOP/156", "completion": "class FUP:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_FUP(FUP):\n    def __init__(self, n, k, target):\n        super().__init__(n)\n        self.k = k\n        self.target = target\n\n    def face_up(self):\n        dp = [[0] * (self.target + 1) for _ in range(self.n + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, self.n + 1):\n            for j in range(1, self.target + 1):\n                for face in range(1, self.k + 1):\n                    if j - face >= 0:\n                        dp[i][j] += dp[i - 1][j - face]\n        \n        return dp[self.n][self.target]", "result": "failed: ", "passed": false}
{"task_id": "OOP/157", "completion": "class DSN:\n    def __init__(self, text):\n        self.text = text\n\nclass SN_DSN(DSN):\n    def Duplicate_string(self):\n        n = len(self.text)\n        if n <= 1:\n            return n\n        \n        max_length = 1\n        \n        for i in range(n):\n            count = 1\n            char = self.text[i]\n            \n            for j in range(n):\n                if i != j and self.text[j] == char:\n                    count += 1\n            \n            if count > max_length:\n                max_length = count\n        \n        return min(max_length + 1, n) if max_length + 1 <= n else max_length", "result": "failed: ", "passed": false}
{"task_id": "OOP/158", "completion": "class OCL:\n    def __init__(self, grid):\n        self.grid = grid\n\n\nclass SN_OCL(OCL):\n    def Ocean_Cell(self):\n        n = len(self.grid)\n        distances = [[float('inf')] * n for _ in range(n)]\n        land_found = False\n        \n        # BFS initialization for all land cells\n        queue = []\n        for i in range(n):\n            for j in range(n):\n                if self.grid[i][j] == 1:\n                    queue.append((i, j))\n                    distances[i][j] = 0\n                    land_found = True\n        \n        if not land_found:\n            return -1\n        \n        # Directions for up, down, left, right movements\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        # BFS to calculate distances from land cells\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and distances[nx][ny] == float('inf'):\n                    distances[nx][ny] = distances[x][y] + 1\n                    queue.append((nx, ny))\n        \n        # Find the maximum distance to the nearest land\n        max_distance = -1\n        for i in range(n):\n            for j in range(n):\n                if self.grid[i][j] == 0:  # Only consider ocean cells\n                    max_distance = max(max_distance, distances[i][j])\n        \n        return max_distance if max_distance != float('inf') else -1", "result": "failed: ", "passed": false}
{"task_id": "OOP/159", "completion": "class LAM:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_LAM(LAM):\n    def Lexicographic_arrangement(self):\n        substrings = [self.s[i:j] for i in range(len(self.s)) for j in range(i + 1, len(self.s) + 1)]\n        substrings.sort()\n        return substrings[-1] if substrings else \"\"", "result": "failed: ", "passed": false}
{"task_id": "OOP/160", "completion": "class TLI:\n    def __init__(self, transactions):\n        self.transactions = transactions\n\nclass SN_TLI(TLI):\n    def Transaction_List(self):\n        invalid_transactions = []\n        transactions_dict = {}\n        \n        for transaction in self.transactions:\n            name, time, amount, city = transaction.split(',')\n            time = int(time)\n            amount = int(amount)\n\n            # Check for amount exceeding $1000\n            if amount > 1000:\n                invalid_transactions.append(transaction)\n                continue\n\n            # Record transactions by name and city\n            if name not in transactions_dict:\n                transactions_dict[name] = []\n            transactions_dict[name].append((time, city, transaction))\n\n        # Check for transactions that are less than or equal to 60 minutes apart\n        for name, trans_list in transactions_dict.items():\n            for i in range(len(trans_list)):\n                time1, city1, trans1 = trans_list[i]\n                for j in range(len(trans_list)):\n                    if i != j:\n                        time2, city2, trans2 = trans_list[j]\n                        if abs(time1 - time2) <= 60 and city1 != city2:\n                            invalid_transactions.append(trans1)\n                            invalid_transactions.append(trans2)\n\n        # Remove duplicates while maintaining order\n        return list(dict.fromkeys(invalid_transactions))", "result": "failed: ", "passed": false}
{"task_id": "OOP/161", "completion": "class SII:\n    def __init__(self, arr1):\n        self.arr1 = arr1\n\nclass SN_SII(SII):\n    def __init__(self, arr1, arr2):\n        super().__init__(arr1)\n        self.arr2 = arr2\n\n    def Strictly_Increasing(self):\n        n = len(self.arr1)\n        m = len(self.arr2)\n\n        # Initialize a set to keep track of the min operations needed\n        dp = {0}  # We start with a \"virtual\" previous number that is lower than any possible arr1 number\n        for i in range(n):\n            next_dp = set()\n            for prev in dp:\n                # Option to keep arr1[i]\n                if i == 0 or self.arr1[i] > prev:\n                    next_dp.add(self.arr1[i])\n                \n                # Option to replace arr1[i] with arr2[j]\n                for num in self.arr2:\n                    if i == 0 or num > prev:\n                        next_dp.add(num)\n            dp = next_dp\n            \n            if not dp:  # If no valid previous numbers, return -1\n                return -1\n                \n        return len(self.arr1) - len(dp)  # The number of operations required to make arr1 strictly increasing", "result": "failed: ", "passed": false}
{"task_id": "OOP/162", "completion": "class MBC:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_MBC(MBC):\n    def Match_Brace(self):\n        stack = []\n        current_string = \"\"\n        \n        for char in self.s:\n            if char == '(':\n                stack.append(current_string)\n                current_string = \"\"\n            elif char == ')':\n                current_string = stack.pop() + current_string[::-1]\n            else:\n                current_string += char\n        \n        return current_string", "result": "failed: ", "passed": false}
{"task_id": "OOP/163", "completion": "class SSA:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_SSA(SSA):\n    def __init__(self, arr, k):\n        super().__init__(arr)\n        self.k = k\n\n    def Sum_subarrays(self):\n        modified_arr = self.arr * self.k\n        max_sum = float('-inf')\n        current_sum = 0\n\n        for num in modified_arr:\n            current_sum += num\n            if current_sum > max_sum:\n                max_sum = current_sum\n            if current_sum < 0:\n                current_sum = 0\n\n        return max_sum", "result": "failed: ", "passed": false}
{"task_id": "OOP/164", "completion": "class UNB:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_UNB(UNB):\n    def __init__(self, n, a, b, c):\n        super().__init__(n)\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def Ugly_number(self):\n        ugly_numbers = [1]\n        i2 = i3 = i5 = 0\n        \n        while len(ugly_numbers) < self.n:\n            next_ugly = min(ugly_numbers[i2] * self.a, ugly_numbers[i3] * self.b, ugly_numbers[i5] * self.c)\n            ugly_numbers.append(next_ugly)\n            \n            if next_ugly == ugly_numbers[i2] * self.a:\n                i2 += 1\n            if next_ugly == ugly_numbers[i3] * self.b:\n                i3 += 1\n            if next_ugly == ugly_numbers[i5] * self.c:\n                i5 += 1\n        \n        return ugly_numbers[self.n - 1]", "result": "failed: ", "passed": false}
{"task_id": "OOP/165", "completion": "class DMM:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_DMM(DMM):\n    def __init__(self, s, pairs):\n        super().__init__(s)\n        self.pairs = pairs\n\n    def Dictionary_minimum(self):\n        from collections import defaultdict\n\n        n = len(self.s)\n        parent = list(range(n))\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootY] = rootX\n\n        for a, b in self.pairs:\n            union(a, b)\n\n        groups = defaultdict(list)\n        for i in range(n):\n            groups[find(i)].append(i)\n\n        result = list(self.s)\n\n        for indices in groups.values():\n            chars = sorted(result[i] for i in indices)\n            for i, idx in enumerate(sorted(indices)):\n                result[idx] = chars[i]\n\n        return ''.join(result)", "result": "passed", "passed": true}
{"task_id": "OOP/166", "completion": "class MBG:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_MBG(MBG):\n    def __init__(self, s, t, maxCost):\n        super().__init__(s)\n        self.t = t\n        self.maxCost = maxCost\n\n    def Maximum_budget(self):\n        max_length = 0\n        current_cost = 0\n        left = 0\n\n        for right in range(len(self.s)):\n            current_cost += abs(ord(self.s[right]) - ord(self.t[right]))\n\n            while current_cost > self.maxCost:\n                current_cost -= abs(ord(self.s[left]) - ord(self.t[left]))\n                left += 1\n\n            max_length = max(max_length, right - left + 1)\n\n        return max_length", "result": "passed", "passed": true}
{"task_id": "OOP/167", "completion": "class DOT:\n    def __init__(self, s):\n        self.s = s\n\nclass SN_DOT(DOT):\n    def __init__(self, s, k):\n        super().__init__(s)\n        self.k = k\n\n    def Delete_Operation(self):\n        stack = []\n        count = 0\n        \n        for char in self.s:\n            if stack and stack[-1][0] == char:\n                count += 1\n                if count == self.k:\n                    for _ in range(self.k):\n                        stack.pop()\n                    count = 0\n            else:\n                stack.append((char, 1))\n                count = 1\n        \n        return ''.join(char for char, _ in stack)", "result": "failed: pop from empty list", "passed": false}
{"task_id": "OOP/168", "completion": "class ESQ:\n    def __init__(self, arr):\n        self.arr = arr\n\nclass SN_ESQ(ESQ):\n    def __init__(self, arr, difference):\n        super().__init__(arr)\n        self.difference = difference\n\n    def Equidistant_subsequence(self):\n        dp = {}\n        max_length = 0\n        \n        for num in self.arr:\n            prev = num - self.difference\n            dp[num] = dp.get(prev, 0) + 1\n            max_length = max(max_length, dp[num])\n\n        return max_length", "result": "passed", "passed": true}
{"task_id": "OOP/169", "completion": "class RDB:\n    def __init__(self, grid):\n        self.grid = grid\n\nclass SN_RDB(RDB):\n    def resource_distribution(self):\n        def dfs(x, y):\n            if x < 0 or x >= len(self.grid) or y < 0 or y >= len(self.grid[0]) or self.grid[x][y] == 0:\n                return 0\n            gold = self.grid[x][y]\n            self.grid[x][y] = 0  # mark the cell as mined\n            gold += dfs(x + 1, y)\n            gold += dfs(x - 1, y)\n            gold += dfs(x, y + 1)\n            gold += dfs(x, y - 1)\n            return gold\n\n        max_gold = 0\n        for i in range(len(self.grid)):\n            for j in range(len(self.grid[0])):\n                if self.grid[i][j] != 0:  # start mining if there's gold\n                    max_gold = max(max_gold, dfs(i, j))\n\n        return max_gold", "result": "failed: ", "passed": false}
{"task_id": "OOP/170", "completion": "class FSG:\n    def __init__(self, n):\n        self.n = n\n\nclass SN_FSG(FSG):\n    def __init__(self, n):\n        super().__init__(n)\n\n    def Forming_String(self):\n        if self.n == 0:\n            return 1\n        if self.n == 1:\n            return 5\n        \n        dp = [[0] * 5 for _ in range(self.n + 1)]\n        vowels = ['a', 'e', 'i', 'o', 'u']\n        \n        for i in range(5):\n            dp[1][i] = 1\n            \n        for length in range(2, self.n + 1):\n            dp[length][0] = dp[length - 1][1]  # 'a' can be followed by 'e'\n            dp[length][1] = dp[length - 1][0] + dp[length - 1][2]  # 'e' can be followed by 'a' or 'i'\n            dp[length][2] = dp[length - 1][0] + dp[length - 1][1] + dp[length - 1][3] + dp[length - 1][4]  # 'i' can be followed by a, e, o, u\n            dp[length][3] = dp[length - 1][2] + dp[length - 1][4]  # 'o' can be followed by 'i' or 'u'\n            dp[length][4] = dp[length - 1][0]  # 'u' can be followed by 'a'\n\n        return sum(dp[self.n])", "result": "passed", "passed": true}
{"task_id": "OOP/171", "completion": "class CKB:\n    def __init__(self, queens):\n        self.queens = queens\n\nclass SN_CKB(CKB):\n    def __init__(self, queens, king):\n        super().__init__(queens)\n        self.king = king\n\n    def checkerboard(self):\n        attacking_queens = []\n        king_x, king_y = self.king\n        \n        for qx, qy in self.queens:\n            if (qx == king_x or qy == king_y or \n                abs(qx - king_x) == abs(qy - king_y)):\n                attacking_queens.append((qx, qy))\n        \n        return attacking_queens", "result": "failed: ", "passed": false}
{"task_id": "OOP/172", "completion": "class SBFD:\n    def __init__(self, nums, left, right):\n        self.nums = nums\n        self.left = left\n        self.right = right\n\n    def find_subarray(self):\n        count = 0\n        n = len(self.nums)\n        \n        for i in range(n):\n            max_in_subarray = self.nums[i]\n            for j in range(i, n):\n                max_in_subarray = max(max_in_subarray, self.nums[j])\n                if self.left <= max_in_subarray <= self.right:\n                    count += 1\n                else:\n                    break\n\n        return count\n\n\nclass SN_FDSB(SBFD):\n    def find_subarray(self):\n        if self.left > self.right:\n            return 0\n        \n        count = 0\n        for num in self.nums:\n            if self.left <= num <= self.right:\n                count += 1\n                \n        return count", "result": "failed: ", "passed": false}
{"task_id": "OOP/173", "completion": "class STR:\n    def __init__(self, s):\n        self.s = s\n\n    def without_duplicates(self):\n        char_index = {}\n        max_length = 0\n        start = 0\n\n        for i, char in enumerate(self.s):\n            if char in char_index and char_index[char] >= start:\n                start = char_index[char] + 1\n            char_index[char] = i\n            max_length = max(max_length, i - start + 1)\n\n        return max_length\n\n\nclass SUB_STR(STR):\n    def without_duplicates(self):\n        char_index = {}\n        max_distance = 0\n\n        for i, char in enumerate(self.s):\n            if char in char_index:\n                max_distance = max(max_distance, i - char_index[char])\n            char_index[char] = i\n\n        return max_distance", "result": "passed", "passed": true}
{"task_id": "OOP/174", "completion": "class PLDR:\n    def __init__(self, number):\n        self.number = number\n\n    def PLind(self):\n        num_str = str(self.number)\n        return num_str == num_str[::-1]\n\nclass SUBPLDR(PLDR):\n    def PLind(self):\n        num_str = str(self.number)\n        return num_str == num_str[::-1] and num_str.isdigit()", "result": "failed: ", "passed": false}
